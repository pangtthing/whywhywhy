/*!
 * jQuery 자바 스크립트 라이브러리 v3.3.1
 * https://jquery.com/
 *
 * Sizzle.js 포함
 * https://sizzlejs.com/
 *
 * 저작권 JS 재단 및 기타 기고자
 * MIT 라이선스에 따라 출시 됨
 * https://jquery.org/license
 *
 * 날짜 : 2018-01-20T17 : 24Z
 */
(function (global, factory) {

	"엄격한 사용";

	if (typeof module === "object"&& typeof module.exports === "object") {

		// CommonJS 및 CommonJS와 유사한 환경에서 적절한 'window'
		//가 존재하면, 팩토리를 실행하고 jQuery를 얻는다.
		//`document`가있는`window`가없는 환경
		// (예 : Node.js), factory를 module.exports로 노출합니다.
		// 이것은 실제 '창'생성의 필요성을 강조합니다.
		// eg var jQuery = require ( "jquery") (window);
		// 자세한 정보는 티켓 # 14549를 참조하십시오.
		module.exports = global.document?
			공장 (전역, 참) :
			함수 (w) {
				if (! w.document) {
					새로운 오류 발생 ( "jQuery는 문서가있는 창 필요");
				}
				공장 반환 (w);
			};
	} else {
		공장 (글로벌);
	}

// 윈도우가 아직 정의되지 않은 경우 이것을 넘겨 준다.
}) (typeof window! == "undefined"? window : this, function (window, noGlobal) {

// Edge <= 12 - 13+, Firefox <= 18 - 45+, IE 10 - 11, Safari 5.1 - 9 이상, iOS 6 - 9.1
// 엄격하지 않은 코드 (예 : ASP.NET 4.5)가 엄격 모드에 액세스 할 때 예외를 throw합니다.
// arguments.callee.caller (trac-13335). 그러나 jQuery 3.0 (2016)부터 엄격 모드가 일반적입니다.
// try 블록에서 그러한 모든 시도가 보호 될 정도로 충분합니다.
"엄격한 사용";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call (Object);

var support = {};

var isFunction = function isFunction (obj) {

      // 지원 : Chrome <= 57, Firefox <= 52
      // 일부 브라우저에서 typeof는 HTML <object> 요소에 대해 "function"을 반환합니다.
      // (즉, typeof document.createElement ( "object") === "function"`).
      // 어떤 * DOM 노드도 함수로 분류하고 싶지는 않습니다.
      return typeof obj === "function"&& type of obj.nodeType! == "number";
  };


var isWindow = function isWindow (obj) {
		return obj! = null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type : true,
		src : true,
		noModule : true
	};

	함수 DOMEval (코드, 의사, 노드) {
		doc = doc || 문서;

		var i,
			script = doc.createElement ( "script");

		script.text = 코드;
		if (node) {
			for (preservedScriptAttributes에 있음) {
				if (node ​​[i]) {
					script [i] = node [i];
				}
			}
		}
		doc.head.appendChild (script) .parentNode.removeChild (script);
	}


function toType (obj) {
	if (obj == null) {
		obj + ""를 반환;
	}

	// 지원 : 안드로이드 <= 2.3 전용 (functionish RegExp)
	return typeof obj === "object"|| typeof obj === "function"?
		class2type [toString.call (obj)] || "개체":
		typeof obj;
}
/ * global 심볼 * /
//이 환경을 .eslintrc.json으로 정의하면 전역 환경을 사용할 위험이 있습니다.
// 다른 곳에서 보호받지 못하면이 모듈에 대해서만 전역을 정의하는 것이 더 안전합니다.



var
	버전 = "3.3.1",

	// jQuery의 로컬 복사본을 정의한다.
	jQuery = function (selector, context) {

		// jQuery 객체는 실제로 init 생성자 인 'enhanced'
		// jQuery가 호출되면 init이 필요합니다 (포함되지 않은 경우 오류가 발생합니다)
		새로운 jQuery.fn.init (selector, context)를 리턴한다.
	},

	// 지원 : 안드로이드 <= 4.0 전용
	// BOM과 NBSP를 다듬 었는지 확인하십시오.
	rtrim = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g;

jQuery.fn = jQuery.prototype = {

	// 사용중인 jQuery의 현재 버전
	jquery : 버전,

	생성자 : jQuery,

	// jQuery 객체의 기본 길이는 0입니다.
	길이 : 0,

	toArray : function () {
		return slice.call (this);
	},

	// 일치하는 요소 집합에서 N 번째 요소 가져 오기 OR
	// 일치하는 요소 세트 전체를 깨끗한 배열로 가져옵니다.
	get : function (num) {

		// 깨끗한 배열의 모든 원소들을 반환한다.
		if (num == null) {
			return slice.call (this);
		}

		// 집합에서 하나의 요소 만 반환합니다.
		return num <0? this [num + this.length] : this [num];
	},

	/ / 요소의 배열을 가져 와서 스택에 밀어
	// (새로운 일치하는 요소 집합을 반환)
	pushStack : function (elems) {

		// 새로운 jQuery와 일치하는 요소 세트를 빌드한다.
		var ret = jQuery.merge (this.constructor (), elems);

		// 이전 객체를 스택에 추가합니다 (참조).
		ret.prevObject = this;

		// 새로 형성된 요소 집합을 반환합니다.
		return ret;
	},

	// 일치하는 집합의 모든 요소에 대해 콜백을 실행합니다.
	각 : function (콜백) {
		return jQuery.each (this, callback);
	},

	지도 : function (콜백) {
		return this.pushStack (jQuery.map (this, function (elem, i) {
			return callback.call (elem, i, elem);
		})));
	},

	슬라이스 : function () {
		return this.pushStack (slice.apply (this, arguments));
	},

	첫 번째 : function () {
		this.eq (0)를 돌려 준다;
	},

	last : function () {
		this.eq (-1)를 돌려 준다;
	},

	eq : function (i) {
		var len = this.length,
			j = + i + (i <0? len : 0);
		this.pushStack (j> = 0 && j <len? [this [j]] : [])를 리턴합니다.
	},

	끝 : function () {
		return this.prevObject || this.constructor ();
	},

	// 내부 용으로 만 사용됩니다.
	// jQuery 메서드가 아니라 Array의 메서드처럼 작동합니다.
	밀어 밀어,
	정렬 : arr.sort,
	splice : arr.splice
};

jQuery.extend = jQuery.fn.extend = function () {
	var 옵션, 이름, src, 사본, copyIsArray, 복제본,
		target = arguments [0] || {},
		i = 1,
		length = arguments.length,
		깊은 = 거짓;

	// 딥 복사 상황 처리
	if (typeof target === "boolean") {
		깊은 = 표적;

		// 부울과 대상을 건너 뜁니다.
		target = arguments [i] || {};
		나는 ++;
	}

	// 대상이 문자열 일 때 대소 문자를 처리합니다 (딥 복사에서 가능).
	if (typeof target! == "object"&&! isFunction (target)) {
		목표 = {};
	}

	// 인수가 하나만 전달되면 jQuery를 확장한다.
	if (i === length) {
		target = this;
		나는--;
	}

	for (; i <길이; i ++) {

		// null이 아니거나 정의되지 않은 값만 처리합니다.
		if ((options = arguments [i])! = null) {

			// 기본 객체를 확장합니다.
			for (옵션 이름) {
				src = target [name];
				복사 = 옵션 [이름];

				// 끝이없는 루프를 방지합니다.
				if (target === copy) {
					잇다;
				}

				// 일반 객체 또는 배열을 병합하는 경우 재귀 호출
				if (deep && copy && (jQuery.isPlainObject (copy) ||
					(copyIsArray = Array.isArray (copy)))) {

					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray (src)? src : [];

					} else {
						clone = src && jQuery.isPlainObject (src)? src : {};
					}

					// 원본 객체를 절대 이동하지 말고 복제하십시오.
					target [name] = jQuery.extend (deep, clone, copy);

				// 정의되지 않은 값을 가져 오지 않습니다.
				} else if (copy! == undefined) {
					목표 [이름] = 복사;
				}
			}
		}
	}

	// 수정 된 객체를 반환합니다.
	반환 목표;
};

jQuery.extend ({

	// 페이지의 각 jQuery 사본마다 고유하다.
	expando : "jQuery"+ (version + Math.random ()) .replace (/ \ D / g, ""),

	// jQuery가 준비된 모듈없이 준비되었다고 가정합니다.
	isReady : true,

	오류 : 함수 (msg) {
		새로운 오류 (msg)를 던지십시오;
	},

	noop : function () {},

	isPlainObject : function (obj) {
		var proto, Ctor;

		// 명백한 네거티브 감지
		// jQuery.type 대신 toString을 사용하여 호스트 객체를 잡습니다.
		if (! obj || toString.call (obj)! == "[object Object]") {
			false를 반환;
		}

		proto = getProto (obj);

		// 프로토 타입이없는 객체 (예 :`Object.create (null)`)는 평이합니다.
		if (! proto) {
			참을 돌려라.
		}

		// 프로토 타입을 가진 객체는 전역 객체 함수에 의해 생성 된 경우 일반 임
		Ctor = hasOwn.call (proto, "constructor") && proto.constructor;
		Ctor를 반환 typeof === "function"&& fnToString.call (Ctor) === ObjectFunctionString;
	},

	isEmptyObject : function (obj) {

		/ * eslint-disable no-unused-vars * /
		// https://github.com/eslint/eslint/issues/6125를 참조하십시오.
		var name;

		for (obj의 이름) {
			false를 반환;
		}
		참을 돌려라.
	},

	// 전역 컨텍스트에서 스크립트를 평가합니다.
	globalEval : function (code) {
		DOMEval (코드);
	},

	각 : function (obj, callback) {
		var 길이, i = 0;

		if (isArrayLike (obj)) {
			length = obj.length;
			for (; i <길이; i ++) {
				if (callback.call (obj [i], i, obj [i]) === false) {
					단절;
				}
			}
		} else {
			for (i in obj) {
				if (callback.call (obj [i], i, obj [i]) === false) {
					단절;
				}
			}
		}

		obj를 반환;
	},

	// 지원 : 안드로이드 <= 4.0 전용
	trim : function (text) {
		return text == null?
			"":
			(text + "") .replace (rtrim, "");
	},

	// 결과는 내부 용으로 만 사용됩니다.
	makeArray : function (arr, results) {
		var ret = results || [];

		if (arr! = null) {
			if (isArrayLike (Object (arr))) {
				jQuery.merge (ret,
					typeof arr === "문자열"?
					[arr] : arr
				);
			} else {
				push.call (ret, arr);
			}
		}

		return ret;
	},

	inArray : function (elem, arr, i) {
		return arr == null? -1 : indexOf.call (arr, elem, i);
	},

	// 지원 : Android <= 4.0 전용, PhantomJS 1 전용
	// push.apply (_, arraylike) 고대 Webkit을 던졌습니다.
	병합 : function (first, second) {
		var len = + second.length,
			j = 0,
			i = first.length;

		for (; j <len; j ++) {
			처음 [i ++] = 초 [j];
		}

		first.length = i;

		처음으로 돌아 가라.
	},

	grep : function (elems, 콜백, 반전) {
		var callbackInverse,
			matches = [],
			i = 0,
			길이 = elems.length,
			callbackExpect =! invert;

		// 배열을 살펴보고 항목 만 저장합니다.
		// validator 함수를 전달한다.
		for (; i <길이; i ++) {
			callbackInverse =! callback (elems [i], i);
			if (callbackInverse! == callbackExpect) {
				matches.push (elems [i]);
			}
		}

		반환 경기;
	},

	// arg는 내부 용으로 만 사용됩니다.
	map : function (elems, 콜백, arg) {
		var 길이, 값,
			i = 0,
			ret = [];

		// 배열을 통해 각 항목을 새 값으로 변환합니다.
		if (isArrayLike (elems)) {
			길이 = elems.length;
			for (; i <길이; i ++) {
				value = 콜백 (elems [i], i, arg);

				if (value! = null) {
					ret.push (value);
				}
			}

		// 객체의 모든 키를 살펴보고,
		} else {
			for (i elems) {
				value = 콜백 (elems [i], i, arg);

				if (value! = null) {
					ret.push (value);
				}
			}
		}

		// 중첩 된 배열을 단순화합니다.
		return concat.apply ([], ret);
	},

	// 객체에 대한 전역 GUID 카운터
	guid : 1,

	// jQuery.support는 Core에서는 사용되지 않지만 다른 프로젝트에서는 해당 객체를 연결합니다.
	// 속성이 있어야하므로 필요합니다.
	지원 : 지원
});

if (typeof Symbol === "function") {
	jQuery.fn [Symbol.iterator] = arr [Symbol.iterator];
}

// class2type 맵을 채 웁니다.
jQuery.each ( "부울 숫자 문자열 함수 배열 날짜 RegExp 객체 오류 기호".split ( ""),
함수 (i, 이름) {
	class2type [ "[object"+ name + "]"] = name.toLowerCase ();
});

함수 isArrayLike (obj) {

	// 지원 : 실제 iOS 8.2 전용 (시뮬레이터에서 재현 불가)
	// 'in` 검사가 JIT 오류를 방지하는 데 사용됩니다 (gh-2145).
	// 가짜 음수 때문에 여기에 hasOwn이 사용되지 않았습니다.
	// IE의 Nodelist 길이 관련
	var length = !! obj && "길이"in obj && obj.length,
		type = toType (obj);

	if (isFunction (obj) || isWindow (obj)) {
		false를 반환;
	}

	반환 유형 === "배열"|| 길이 === 0 ||
		typeof length === "number"&& length> 0 && (length - 1) in obj;
}
var Sizzle =
/ *!
 * 지글 거리는 CSS 선택기 엔진 v2.3.3
 * https://sizzlejs.com/
 *
 * 저작권 jQuery Foundation 및 기타 기여자
 * MIT 라이선스에 따라 출시 됨
 * http://jquery.org/license
 *
 * 날짜 : 2016-08-08
 * /
(함수 (윈도우) {

var i,
	지원하다,
	Expr,
	getText,
	isXML,
	토큰 화,
	엮다,
	고르다,
	외측의 Context,
	sortInput,
	hasDuplicate,

	// 로컬 문서 변수
	setDocument,
	문서,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	성냥,
	포함,

	// 인스턴스 관련 데이터
	expando = "sizzle"+ 1 * 새 날짜 (),
	preferredDoc = window.document,
	dirruns = 0,
	완료 = 0,
	classCache = createCache (),
	tokenCache = createCache (),
	compilerCache = createCache (),
	sortOrder = function (a, b) {
		if (a === b) {
			hasDuplicate = true;
		}
		0을 반환;
	},

	// 인스턴스 메소드
	hasOwn = ({}). hasOwnProperty,
	arr = [],
	팝 = arr.pop,
	push_native = arr.push,
	푸시 = arr.push,
	슬라이스 = arr.slice,
	// 네이티브보다 빠르기 때문에 제거 된 인덱스를 사용하십시오.
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function (list, elem) {
		var i = 0,
			len = list.length;
		for (; i <len; i ++) {
			if (list [i] === elem) {
				i를 되 돌린다.
			}
		}
		-1을 반환합니다.
	},

	booleans = "checked | selected | async | autofocus | autoplay | controls | defer | disabled | hidden | ismap | loop | multiple | open | readonly | required | scoped",

	// 정규 표현식

	// http://www.w3.org/TR/css3-selectors/#whitespace
	공백 = "[\\ x20 \\ t \\ r \\ n \\ f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	식별자 = "(? : \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) +",

	// 속성 선택자 : http://www.w3.org/TR/selectors/#attribute-selectors
	속성 = "\\ ["+ 공백 + "* ("+ 식별자 + ") (? :"+ 공백 +
		// 연산자 (캡처 2)
		"* ([* ^ $ |! ~]? =)"+ 공백 +
		// "속성 값은 CSS 식별자 [캡처 5] 또는 문자열 [캡처 3 또는 캡처 4]이어야합니다."
		"* (? : '((? : \\\\. | [^ \\\\']) *) '| \"((? : \\\\. | [^ \\\\\ "] ) *) \ "| ("+ 식별자 + ")) |)"+ 공백 +
		"* \\]",

	pseudos = ":("+ 식별자 + ") (? : \\ (("+ "
		// preFilter에서 tokenize를 필요로하는 선택 자의 수를 줄이려면 인수를 선호하십시오 :
		// 1. 인용 (캡처 3, 캡처 4 또는 캡처 5)
		"((? : \\\\. | [^ \\\\ ']) *)'| \"(? : \\\\. | [^ \\\\ "]) *) \ ") |"+
		// 2. 단순 (캡처 6)
		"((? : \\\\. | [^ \\\\ () [\\]] |"+ 속성 + ") *) |" +
		// 3. 기타 (캡처 2)
		". *"+
		") \\) |)"),

	// 앞뒤에 공백이 아닌 문자를 캡처하는 선행 및 비 이스케이프 후행 공백
	rwhitespace = 새로운 RegExp (공백 + "+", "g"),
	rtrim = new RegExp ( "^"+ 공백 + "+ | (? : ^ | [^ \\\\]) (? : \\\\.) *)"+ 공백 + "$", "g "),

	rcomma = new RegExp ( "^"+ 공백 + "*"+ 공백 + "*"),
	rcombinators = 새로운 RegExp ( "^"+ 공백 + "* ([> + ~] |"+ 공백 + ")"+ 공백 + "*")

	rattributeQuotes = new RegExp ( "="+ 공백 + "* ([^ \\] '\"] *?) "+ 공백 +"* \\] ","g "

	rpseudo = 새 RegExp (의사),
	ridentifier = 새로운 RegExp ( "^"+ 식별자 + "$"),

	matchExpr = {
		"ID": 새 RegExp ( "^ # ("+ 식별자 + ")"),
		"CLASS": 새 RegExp ( "^ \\. ("+ 식별자 + ")"),
		"TAG": 새 RegExp ( "^ ("+ 식별자 + "| [*])),
		"ATTR": 새로운 RegExp ( "^"+ 속성),
		"PSEUDO": 새 RegExp ( "^"+ 의사),
		"자식": 새 RegExp ( "^ :( 첫 번째 | 마지막 | n 번째 | n 번째 - 마지막) - (자식 | of-type) (? : \\ ("+ 공백 +
			"* (? : ([+ -] |)"+ 공백 + "*
			"* (\\ d +) |))"+ 공백 + "* \\) |)", "i"),
		"bool": 새 ​​RegExp ( "^ (?:"+ booleans + ") $", "i"),
		// .is ()를 구현하는 라이브러리에서 사용.
		// 우리는`select`에서 POS와 일치하는 것을 사용합니다.
		"needsContext": 새로운 RegExp ( "^"+ 공백 + "* [> + ~] | : (홀수 | eq | gt | lt | nth |
			공백 + "* ((? : - \\ d)? \\ d *)"+ 공백 + "* \\) |) (? = [^ -] | $)", "i")
	},

	rinputs = / ^ (?: input | select | textarea | button) $ / i,
	rheader = / ^ h \ d $ / i,

	기본 = / ^ [^ {] + \ {\ s * \ [기본 \ w /

	// 쉽게 파싱 가능 / 검색 가능한 ID 또는 TAG 또는 CLASS 선택기
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\((w\)-)+))$/,

	rsibling = / [+ ~] /,

	// CSS 탈출
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp ( "\\\\ ([\\ da-f] {1,6}"+ 공백 + "? ("+ 공백 + ") |.)", "ig"),
	funescape = function (_, escaped, escapedWhitespace) {
		var high = "0x"+ 이스케이프 됨 - 0x10000;
		// NaN은 비 코드 포인트를 의미합니다.
		// 지원 : Firefox <24
		// + "0x"의 해결 방법 오류 숫자 해석
		높이 돌아 오십시오! == 높은 || 탈출 한 공백?
			탈출 :
			높음 <0?
				// BMP 코드 포인트
				String.fromCharCode (높음 + 0x10000) :
				// 보조 평면 코드 포인트 (서로 게이트 쌍)
				String.fromCharCode (high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
	},

	// CSS 문자열 / 식별자 직렬화
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = / ([\ 0- \ x1f \ x7f] | ^ -? \ d) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g,
	fcssescape = function (ch, asCodePoint) {
		if (asCodePoint) {

			// U + 0000은 U + FFFD로 바뀝니다. 대체 문자
			if (ch === "\ 0") {
				return "\ uFFFD";
			}

			// 제어 문자와 (위치에 따라) 숫자가 코드 포인트로 이스케이프됩니다.
			return ch.slice (0, -1) + "\\"+ ch.charCodeAt (ch.length - 1) .toString (16) + "";
		}

		// 다른 잠재적으로 특수한 ASCII 문자는 백 슬래시로 이스케이프 처리됩니다.
		return "\\"+ ch;
	},

	// iframe에 사용
	// setDocument ()를 참조하십시오.
	// 함수 래퍼를 제거하면 "Permission Denied"
	// IE의 오류
	unloadHandler = function () {
		setDocument ();
	},

	disabledAncestor = addCombinator (
		함수 (elem) {
			return elem.disabled === true && (elem의 "form"| elem의 "label");
		},
		{dir : "parentNode", 다음 : "범례"}
	);

// push.apply (_, NodeList)에 최적화
시도 {
	push.apply (
		(arr = slice.call (preferredDoc.childNodes)),
		preferredDoc.childNodes
	);
	// 지원 : Android <4.0
	// 자동으로 실패한 감지 push.apply
	arr [preferredDoc.childNodes.length] .nodeType;
} catch (e) {
	푸시 = {적용 : arr.length?

		// 가능한 경우 슬라이스 활용
		함수 (target, els) {
			push_native.apply (target, slice.call (els));
		} :

		// 지원 : IE <9
		// 그렇지 않으면 직접 추가합니다.
		함수 (target, els) {
			var j = target.length,
				i = 0;
			// NodeList.length를 신뢰할 수 없습니다.
			while ((target [j ++] = els [i ++])) {}
			target.length = j - 1;
		}
	};
}

함수 Sizzle (선택기, 컨텍스트, 결과, 시드) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		컨텍스트는 기본적으로 document이므로 // nodeType의 기본값은 9입니다.
		nodeType = context? context.nodeType : 9;

	결과 = 결과 || [];

	// 셀렉터 또는 컨텍스트가 유효하지 않은 호출에서 일찍 반환
	if (typeof selector! == "string"||! selector ||
		nodeType! == 1 && nodeType! == 9 && nodeType! == 11) {

		결과를 반환;
	}

	// HTML 문서에서 필터를 사용하지 않고 바로 가기 작업을 시도합니다.
	if (! seed) {

		if ((context? context.ownerDocument || context : preferredDoc)! == document) {
			setDocument (context);
		}
		context = context || 문서;

		if (documentIsHTML) {

			// 셀렉터가 충분히 간단하면 "get * By *"DOM 메소드를 사용해보십시오
			// (메소드가 존재하지 않는 DocumentFragment 컨텍스트 제외)
			if (nodeType! == 11 && (match = rquickExpr.exec (selector))) {

				// ID 선택기
				if ((m = match [1])) {

					// 문서 문맥
					if (nodeType === 9) {
						if ((elem = context.getElementById (m))) {

							// 지원 : IE, Opera, Webkit
							// TODO : 버전 식별
							// getElementById는 ID 대신 이름으로 요소를 일치시킬 수 있습니다.
							if (elem.id === m) {
								results.push (elem);
								결과를 반환;
							}
						} else {
							결과를 반환;
						}

					// 요소 컨텍스트
					} else {

						// 지원 : IE, Opera, Webkit
						// TODO : 버전 식별
						// getElementById는 ID 대신 이름으로 요소를 일치시킬 수 있습니다.
						if (newContext && (elem = newContext.getElementById (m)) &&
							contains (context, elem) &&
							elem.id === m) {

							results.push (elem);
							결과를 반환;
						}
					}

				// 유형 선택기
				} else if (match [2]) {
					push.apply (results, context.getElementsByTagName (selector));
					결과를 반환;

				// 클래스 선택자
				} else if ((m = match [3]) && support.getElementsByClassName &&
					context.getElementsByClassName) {

					push.apply (results, context.getElementsByClassName (m));
					결과를 반환;
				}
			}

			// querySelectorAll 활용
			if (support.qsa &&)
				! compilerCache [selector + ""] &&
				(! rbuggyQSA ||! rbuggyQSA.test (selector))) {

				if (nodeType! == 1) {
					newContext = 컨텍스트;
					newSelector = 선택자;

				// qSA는 Element 컨텍스트 외부를 본다.
				//이 해결 방법 기술에 대한 Andrew Dupont에게 감사드립니다.
				// 지원 : IE <= 8
				// 객체 요소를 제외합니다.
				} else if (context.nodeName.toLowerCase ()! == "object") {

					// 컨텍스트 ID를 캡처하여 필요한 경우 먼저 설정합니다.
					if ((nid = context.getAttribute ( "id"))) {
						nid = nid.replace (rcssescape, fcssescape);
					} else {
						context.setAttribute ( "id", (nid = expando));
					}

					// 목록의 모든 selector 앞에 접두사를 붙입니다.
					groups = tokenize (selector);
					i = groups.length;
					while (i--) {
						groups [i] = "#"+ nid + ""+ toSelector (그룹 [i]);
					}
					newSelector = groups.join ( ",");

					// 형제 선택자의 컨텍스트를 확장합니다.
					newContext = rsibling.test (selector) && testContext (context.parentNode) ||
						문맥;
				}

				if (newSelector) {
					시도 {
						push.apply (결과,
							newContext.querySelectorAll (newSelector)
						);
						결과를 반환;
					} catch (qsaError) {
					} finally {
						if (nid === expando) {
							context.removeAttribute ( "id");
						}
					}
				}
			}
		}
	}

	// 다른 모든
	return select (selector.replace (rtrim, "$ 1"), 컨텍스트, 결과, 시드);
}

/ **
 * 제한된 크기의 키 - 값 캐시 생성
 * @returns {function (string, object)} Object 데이터를 다음과 같이 저장 한 후 반환합니다.
 * property name (공백 접미사) 문자열 및 (캐시가 Expr.cacheLength보다 큰 경우)
 * 가장 오래된 항목 삭제
 * /
함수 createCache () {
	var keys = [];

	함수 캐시 (키, 값) {
		// 원시 프로토 타입 속성과의 충돌을 피하기 위해 (key + "") 사용 (Issue # 157 참조)
		if (keys.push (key + "")> Expr.cacheLength) {
			// 가장 최근의 항목 만 유지
			캐시 삭제 [keys.shift ()];
		}
		return (cache [key + ""] = value);
	}
	리턴 캐시;
}

/ **
 * Sizzle이 특수 용도로 사용하는 기능을 표시하십시오.
 * @param {Function} fn 표시 할 함수.
 * /
function markFunction (fn) {
	fn [expando] = true;
	fn을 반환;
}

/ **
 * 요소를 사용한 테스트 지원
 * @param {Function} fn 생성 된 요소를 전달하고 부울 결과를 반환합니다.
 * /
function assert (fn) {
	var el = document.createElement ( "fieldset");

	시도 {
		return !! fn (el);
	} catch (e) {
		false를 반환;
	} finally {
		// 기본적으로 부모로부터 제거
		if (el.parentNode) {
			el.parentNode.removeChild (el);
		}
		// IE에서 메모리를 해제하십시오.
		el = null;
	}
}

/ **
 * 지정된 attrs에 대해 동일한 핸들러를 추가합니다.
 * @param {String} attrs 파이프로 구분 된 속성 목록
 * @param {Function} handler 적용 할 메소드입니다.
 * /
함수 addHandle (attrs, handler) {
	var arr = attrs.split ( "|"),
		i = arr.length;

	while (i--) {
		Expr.attrHandle [arr [i]] = handler;
	}
}

/ **
 * 두 형제 자매의 문서 순서를 확인합니다.
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} a가 b보다 선행하면 0보다 작고, b가 오는 경우 0보다 큰 것을 반환합니다.
 * /
function siblingCheck (a, b) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// 양쪽 노드에서 사용 가능한 경우 IE sourceIndex 사용
	if (diff) {
		return diff;
	}

	// b가 뒤에 오는 지 확인
	if (cur) {
		while ((cur = cur.nextSibling))) {
			if (cur === b) {
				-1을 반환합니다.
			}
		}
	}

	돌아온다? 1 : -1;
}

/ **
 * 입력 형식에 의사 (pseudo)로 사용할 함수를 반환합니다.
 * @param {String} 유형
 * /
함수 createInputPseudo (유형) {
	반환 함수 (elem) {
		var name = elem.nodeName.toLowerCase ();
		return name === "input"&& elem.type === type;
	};
}

/ **
 * 버튼에 의사 (pseudos)로 사용할 함수를 반환합니다.
 * @param {String} 유형
 * /
함수 createButtonPseudo (유형) {
	반환 함수 (elem) {
		var name = elem.nodeName.toLowerCase ();
		return (name === "input"|| name === "button") && elem.type === type;
	};
}

/ **
 * pseudo에 사용할 함수를 다음과 같이 반환합니다. enabled / : disabled
 * @param {Boolean} 사용 안 함 true : 사용 안 함; for : enabled
 * /
함수 createDisabledPseudo (비활성화 됨) {

	// 알려진 : 비활성화 된 오 탐지 : fieldset [disabled]> 범례 : nth-of-type (n + 2) : can-disable
	반환 함수 (elem) {

		// 특정 요소 만 일치 할 수 있습니다 : enabled 또는 : disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form"in elem) {

			// 사용 가능하지 않은 관련 요소에서 상속 된 비활성화 여부 확인 :
			// 비활성화 된 필드 세트에 폼 관련 요소를 나열했습니다.
			// https://html.spec.whatwg.org/multipage/forms.html#category-listed
			// https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			비활성화 된 optgroup의 옵션 요소
			// https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// 이러한 모든 요소에는 "form"속성이 있습니다.
			if (elem.parentNode && elem.disabled === false) {

				// 존재하는 경우 옵션 요소가 부모 optgroup에 연기됩니다.
				if (elem의 "label") {
					if (elem.parentNode의 "label") {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// 지원 : IE 6 - 11
				// isDisabled 단축키 속성을 사용하여 비활성화 된 필드 세트 조상을 확인합니다.
				return elem.isDisabled === 비활성화 됨 ||

					// isDisabled가없는 경우 수동으로 확인하십시오.
					/ * jshint -W018 * /
					elem.isDisabled! ==! disabled &&
						disabledAncestor (elem) === 사용 안 함;
			}

			return elem.disabled === disabled;

		// 비활성화 된 속성을 신뢰하기 전에 비활성화 할 수없는 요소를 알아 낸다.
		// 일부 희생자가 우리의 그물 (레이블, 범례, 메뉴, 트랙)에 잡히지 만,
		// 부울 값을 가지지 않고도 그것들에 존재합니다.
		} else if (elem의 "label") {
			return elem.disabled === disabled;
		}

		// 나머지 요소는 enabled 또는 : disabled입니다.
		false를 반환;
	};
}

/ **
 * 위치 정보에 pseudo로 사용할 함수를 반환합니다.
 * @param {함수} fn
 * /
함수 createPositionalPseudo (fn) {
	return markFunction (function (argument) {
		인수 = + 인수;
		return markFunction (function (seed, matches) {
			var j,
				matchIndexes = fn ([], seed.length, argument),
				i = matchIndexes.length;

			// 지정된 인덱스에서 발견 된 요소 일치
			while (i--) {
				if (seed [(j = matchIndexes [i])]) {
					seed [j] =! (matches [j] = seed [j]);
				}
			}
		});
	});
}

/ **
 * 지글 거리기 컨텍스트로 노드의 유효성을 검사합니다.
 * @param {Element | Object =} 컨텍스트
 * @returns {Element | Object | Boolean} 허용되는 경우 입력 노드, 그렇지 않으면 허위 값
 * /
함수 testContext (context) {
	context && typeof context.getElementsByTagName! == "정의되지 않음"&& context;
}

// 편의를 위해 vars 지원
support = Sizzle.support = {};

/ **
 * XML 노드 감지
 * @param {Element | Object} elem 요소 또는 문서
 * @returns {Boolean} elem이 HTML이 아닌 XML 노드이면 true입니다.
 * /
isXML = Sizzle.isXML = function (elem) {
	// documentElement는 아직 존재하지 않는 경우에 대해 검증됩니다.
	// (예 : IE에서로드하는 iframe - # 4833)
	var documentElement = elem && (elem.ownerDocument || elem) .documentElement;
	documentElement를 반환합니까? documentElement.nodeName! == "HTML": false;
};

/ **
 * 현재 문서를 기반으로 문서 관련 변수를 한 번 설정합니다.
 * @param {Element | Object} [doc] 문서를 설정하는 데 사용할 요소 또는 문서 객체
 * @returns {Object} 현재 문서를 반환합니다.
 * /
setDocument = Sizzle.setDocument = function (node) {
	var hasCompare, subWindow,
		doc = node? node.ownerDocument || node : preferredDoc;

	// doc가 유효하지 않거나 이미 선택되어있는 경우 일찍 반환
	if (doc === document || doc.nodeType! == 9 ||! doc.documentElement) {
		문서를 반환;
	}

	// 전역 변수 업데이트
	document = doc;
	docElem = document.documentElement;
	documentIsHTML =! isXML (문서);

	// 지원 : IE 9-11, Edge
	// 언로드 후 iframe 문서에 액세스하면 "permission denied"오류가 발생합니다 (jQuery # 13936).
	if (preferredDoc! == document &&
		(subWindow = document.defaultView) && subWindow.top! == subWindow) {

		// 지원 : IE 11, Edge
		if (subWindow.addEventListener) {
			subWindow.addEventListener ( "unload", unloadHandler, false);

		// 지원 : IE 9-10 만
		} else if (subWindow.attachEvent) {
			subWindow.attachEvent ( "onunload", unloadHandler);
		}
	}

	/ * 속성
	-------------------------------------------------- -------------------- * /

	// 지원 : IE <8
	// getAttribute가 속성이 아니라 속성을 실제로 반환하는지 확인합니다.
	// (IE8 불린 제외)
	support.attributes = assert (function (el) {
		el.className = "i";
		return! el.getAttribute ( "className");
	});

	/ * getElement (s) By *
	-------------------------------------------------- -------------------- * /

	// getElementsByTagName ( "*")가 요소 만 반환하는지 확인
	support.getElementsByTagName = assert (function (el) {
		el.appendChild (document.createComment ( ""));
		return! el.getElementsByTagName ( "*"). length;
	});

	// 지원 : IE <9
	support.getElementsByClassName = rnative.test (document.getElementsByClassName);

	// 지원 : IE <10
	// getElementById가 이름으로 요소를 반환하는지 확인
	// 깨진 getElementById 메소드는 프로그래밍 방식으로 설정된 이름을 선택하지 않지만,
	// 그래서 roundabout getElementsByName 테스트를 사용한다.
	support.getById = assert (function (el) {
		docElem.appendChild (el) .id = expando;
		return! document.getElementsByName || ! document.getElementsByName (expando) .length;
	});

	// ID 필터 및 찾기
	if (support.getById) {
		Expr.filter [ "ID"] = 함수 (id) {
			var attrId = id.replace (runescape, funescape);
			반환 함수 (elem) {
				return elem.getAttribute ( "id") === attrId;
			};
		};
		Expr.find [ "ID"] = 함수 (id, context) {
			if (typeof context.getElementById! == "undefined"&& documentIsHTML) {
				var elem = context.getElementById (id);
				elem을 돌려 주시겠습니까? [elem] : [];
			}
		};
	} else {
		Expr.filter [ "ID"] = 함수 (id) {
			var attrId = id.replace (runescape, funescape);
			반환 함수 (elem) {
				var 노드 = typeof elem.getAttributeNode! == "정의되지 않음"&&
					elem.getAttributeNode ( "id");
				반환 노드 && node.value === attrId;
			};
		};

		// 지원 : IE 6 - 7 전용
		// getElementById가 찾기 바로 가기로 신뢰할 수 없습니다.
		Expr.find [ "ID"] = 함수 (id, context) {
			if (typeof context.getElementById! == "undefined"&& documentIsHTML) {
				var 노드, i, elems,
					elem = context.getElementById (id);

				if (elem) {

					// id 속성을 확인합니다.
					node = elem.getAttributeNode ( "id");
					if (node ​​&& node.value === id) {
						return [elem];
					}

					// getElementsByName으로 돌아갑니다.
					elems = context.getElementsByName (id);
					i = 0;
					while ((elem = elems [i ++])) {
						node = elem.getAttributeNode ( "id");
						if (node ​​&& node.value === id) {
							return [elem];
						}
					}
				}

				return [];
			}
		};
	}

	// 태그
	Expr.find [ "TAG"] = support.getElementsByTagName?
		함수 (태그, 컨텍스트) {
			if (typeof context.getElementsByTagName! == "undefined") {
				return context.getElementsByTagName (tag);

			// DocumentFragment 노드에는 gEBTN이 없습니다.
			} else if (지원 .qsa) {
				return context.querySelectorAll (tag);
			}
		} :

		함수 (태그, 컨텍스트) {
			var elem,
				tmp = [],
				i = 0,
				// 우연히도 DocumentFragment 노드에도 (깨진) gEBTN이 나타납니다.
				결과 = context.getElementsByTagName (태그);

			// 가능한 코멘트 필터링
			if (tag === "*") {
				while ((elem = 결과 [i ++])) {
					if (elem.nodeType === 1) {
						tmp.push (elem);
					}
				}

				return tmp;
			}
			결과를 반환;
		};

	// 수업
	Expr.find [ "CLASS"] = support.getElementsByClassName && function (className, context) {
		if (typeof context.getElementsByClassName! == "undefined"&& documentIsHTML) {
			return context.getElementsByClassName (className);
		}
	};

	/ * QSA / matchesSelector
	-------------------------------------------------- -------------------- * /

	// QSA 및 matchesSelector 지원

	// matchesSelector (: active)는 참일 때 거짓을보고합니다 (IE9 / Opera 11.5).
	rbuggyMatches = [];

	// qSa (: focus)는 true 일 때 false를보고합니다 (Chrome 21).
	// IE8 / 9의 버그로 인해 오류가 발생합니다.
	// iframe에서`document.activeElement`가 액세스 될 때마다 //
	// 그래서 IE의 오류를 피하기 위해 항상 QSA를 통과하는 포커스를 허용합니다.
	// https://bugs.jquery.com/ticket/13378을 참조하십시오.
	rbuggyQSA = [];

	if ((support.qsa = rnative.test (document.querySelectorAll))) {
		// QSA 정규 표현식을 작성하십시오.
		// Diego Perini에서 채택 된 Regex 전략
		assert (function (el) {
			// 선택은 빈 문자열로 설정됩니다.
			// 이것은 명시 적으로 IE의 처리를 테스트하는 것입니다.
			// 부울 content 속성을 설정합니다.
			// 그 존재가 충분해야하기 때문에
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild (el) .innerHTML = "<a id='" + expando + "'> </a>"+
				"<select id = '"+ expando + "- \ r \\'msallowcapture = ''>"+
				"<option selected = ''> </ option> </ select>";

			// 지원 : IE8, Opera 11-12.16
			// 빈 문자열이 ^ = 또는 $ = 또는 * = 뒤에 올 때 아무것도 선택하지 않아야합니다.
			// 테스트 속성은 Opera에서는 알 수 없지만 WinRT에서는 "안전"해야합니다.
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if (el.querySelectorAll ( "[msallowcapture ^ = '']").). 길이) {
				rbuggyQSA.push ( "[* ^ $] ="+ 공백 + "* (?: ''| \"\ ")");
			}

			// 지원 : IE8
			// Boolean 속성과 "value"는 올바르게 처리되지 않습니다.
			if (! el.querySelectorAll ( "[selected]"). length) {
				rbuggyQSA.push ( "\\ ["+ 공백 + "* (?: 값 |"+ 불린 + ")");
			}

			// 지원 : Chrome <29, Android <4.4, Safari <7.0+, iOS <7.0+, PhantomJS <1.9.8+
			if (! el.querySelectorAll ( "[id ="+ expando + "-]") .length) {
				rbuggyQSA.push ( "~ ~");
			}

			// Webkit / Opera - : checked는 선택된 옵션 요소를 반환해야합니다.
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8은 여기에 에러를 던지고 나중의 테스트를 볼 수 없다.
			if (! el.querySelectorAll ( ": checked"). length) {
				rbuggyQSA.push ( ": checked");
			}

			// 지원 : Safari 8 이상, iOS 8 이상
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// 인 페이지 'selector # id 형제 - 연결자 selector'가 실패합니다.
			if (! el.querySelectorAll ( "a #"+ expando + "+ *") .length) {
				rbuggyQSA.push ( ". #. + [+ ~]");
			}
		});

		assert (function (el) {
			el.innerHTML = "<a href='' disabled='disabled'> </a>"+
				"<select disabled = 'disabled'> <option /> </ select>";

			// 지원 : Windows 8 Native Apps
			// .innerHTML 할당 중에 type 및 name 속성이 제한됩니다.
			var input = document.createElement ( "input");
			input.setAttribute ( "type", "hidden");
			el.appendChild (입력) .setAttribute ( "name", "D");

			// 지원 : IE8
			// name 속성의 대소 문자를 구분합니다.
			if (el.querySelectorAll ( "[name = d]"). length) {
				rbuggyQSA.push ( "name"+ 공백 + "* [* ^ $ |! ~]? =");
			}

			// FF 3.5 - : : 활성화 됨 / : 비활성화 된 요소와 숨겨진 요소 (숨겨진 요소가 계속 활성화 됨)
			// IE8은 여기에 에러를 던지고 나중의 테스트를 볼 수 없다.
			if (el.querySelectorAll ( ": enabled"). 길이! == 2) {
				rbuggyQSA.push ( ": enabled", ": disabled");
			}

			// 지원 : IE9-11 +
			// IE의 : 비활성화 된 선택기가 비활성화 된 필드 집합의 자식을 선택하지 않습니다.
			docElem.appendChild (el) .disabled = true;
			if (el.querySelectorAll ( ": disabled"). 길이! == 2) {
				rbuggyQSA.push ( ": enabled", ": disabled");
			}

			// Opera 10-11은 쉼표 뒤에있는 잘못된 의사를 던지지 않습니다.
			el.querySelectorAll ( "* ,: x");
			rbuggyQSA.push ( ",. * :");
		});
	}

	if ((support.matchesSelector = rnative.test ((matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector))))) {

		assert (function (el) {
			// matchesSelector를 수행 할 수 있는지 확인합니다.
			// 연결이 끊어진 노드에서 (IE 9)
			support.disconnectedMatch = matches.call (el, "*");

			// 예외가 발생하면 실패합니다.
			// Gecko는 에러가 아니고 대신 false를 반환합니다.
			matches.call (el, "[s! = ''] : x");
			rbuggyMatches.push ( "! =", pseudos);
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp (rbuggyQSA.join ( "|"));
	rbuggyMatches = rbuggyMatches.length && new RegExp (rbuggyMatches.join ( "|"));

	/ * 포함
	-------------------------------------------------- -------------------- * /
	hasCompare = rnative.test (docElem.compareDocumentPosition);

	// 요소에 다른 요소가 포함되어 있습니다.
	// 의도적으로 자기 독점
	// 마찬가지로, 요소 자체는 포함하지 않습니다.
	contains = hasCompare || rnative.test (docElem.contains)?
		함수 (a, b) {
			var adown = a.nodeType === 9? a.documentElement : a,
				bup = b && b.parentNode;
			=== bup을 돌려 준다. !! (bup && bode.nodeType === 1 && (
				adown.contains?
					adown.contains (bup) :
					a.compareDocumentPosition && a.compareDocumentPosition (bup) & 16
			));
		} :
		함수 (a, b) {
			if (b) {
				while ((b = b.parentNode)) {
					if (b === a) {
						참을 돌려라.
					}
				}
			}
			false를 반환;
		};

	/ * 분류
	-------------------------------------------------- -------------------- * /

	// 문서 정렬 정렬
	sortOrder = hasCompare?
	함수 (a, b) {

		// 중복 제거 플래그
		if (a === b) {
			hasDuplicate = true;
			0을 반환;
		}

		// 하나의 입력에만 compareDocumentPosition이 있으면 메서드 존재에 정렬
		var compare =! a.compareDocumentPosition -! b.compareDocumentPosition;
		if (compare) {
			반환 비교;
		}

		// 두 입력이 모두 같은 문서에 속한 경우 위치 계산
		비교 = (a.ownerDocument || a) === (b.ownerDocument || b)?
			a.compareDocumentPosition (b) :

			// 그렇지 않으면 연결이 끊어 졌다는 것을 알게됩니다.
			1;

		// 연결이 끊어진 노드
		if (비교 & 1 ||
			(! support.sortDetached && b.compareDocumentPosition (a) === 비교)) {

			// 원하는 문서와 관련된 첫 번째 요소를 선택하십시오.
			if (a === document || a.ownerDocument === preferredDoc && contains (preferredDoc, a)) {
				-1을 반환합니다.
			}
			if (b === document || b.ownerDocument === preferredDoc && contains (preferredDoc, b)) {
				1을 반환;
			}

			// 원래 주문 유지
			sortInput을 반환합니까?
				(indexOf (sortInput, a) - indexOf (sortInput, b)) :
				0;
		}

		비교 & 4를 반환합니까? -1 : 1;
	} :
	함수 (a, b) {
		// 노드가 동일하면 일찍 종료하십시오.
		if (a === b) {
			hasDuplicate = true;
			0을 반환;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [a],
			bp = [b];

		// 부모가없는 노드는 문서이거나 연결이 끊어져 있습니다.
		if (! aup ||! bup) {
			=== 문서를 반송 하시겠습니까? -1 :
				b === 문서? 1 :
				응? -1 :
				멍청 아? 1 :
				sortInput?
				(indexOf (sortInput, a) - indexOf (sortInput, b)) :
				0;

		// 노드가 형제이면 빠른 검사를 할 수 있습니다.
		} else if (aup === bup) {
			반환 siblingCheck (a, b);
		}

		// 그렇지 않으면 비교를 위해 조상의 전체 목록이 필요합니다.
		cur = a;
		while ((cur = cur.parentNode))) {
			ap.unshift (cur);
		}
		cur = b;
		while ((cur = cur.parentNode))) {
			bp.unshift (cur);
		}

		// 불일치를 찾기 위해 나무를 걸어 내려갑니다.
		while (ap [i] === bp [i]) {
			나는 ++;
		}

		내가 돌아 왔니?
			// 노드가 공통 조상을 가지고 있다면 형제 수표를 만든다.
			siblingCheck (ap [i], bp [i]) :

			// 우리 문서의 노드가 먼저 정렬됩니다.
			ap [i] === preferredDoc? -1 :
			bp [i] === preferredDoc? 1 :
			0;
	};

	문서를 반환;
};

Sizzle.matches = function (expr, elements) {
	return Sizzle (expr, null, null, elements);
};

Sizzle.matchesSelector = function (elem, expr) {
	// 필요한 경우 문서 변수를 설정합니다.
	if ((elem.ownerDocument || elem)! == document) {
		setDocument (elem);
	}

	// 속성 선택자가 인용되었는지 확인하십시오.
	expr = expr.replace (rattributeQuotes, "= '$ 1']");

	if (support.matchesSelector && documentIsHTML &&
		! compilerCache [expr + ""] &&
		(! rbuggyMatches ||! rbuggyMatches.test (expr)) &&
		(! rbuggyQSA ||! rbuggyQSA.test (expr))) {

		시도 {
			var ret = matches.call (elem, expr);

			// 연결이 끊어진 노드에서 IE 9의 matchesSelector가 false를 반환합니다.
			if (ret || support.disconnectedMatch ||
					// 또한 연결이 끊어진 노드는 문서에 있다고 말합니다.
					// IE 9의 조각
					elem.document && elem.document.nodeType! == 11) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle (expr, document, null, [elem]) .length> 0;
};

Sizzle.contains = function (context, elem) {
	// 필요한 경우 문서 변수를 설정합니다.
	if ((context.ownerDocument || context)! == document) {
		setDocument (context);
	}
	return contains (context, elem);
};

Sizzle.attr = function (elem, name) {
	// 필요한 경우 문서 변수를 설정합니다.
	if ((elem.ownerDocument || elem)! == document) {
		setDocument (elem);
	}

	var fn = Expr.attrHandle [name.toLowerCase ()],
		// Object.prototype 속성에 속지 마십시오 (jQuery # 13807).
		val = fn && hasOwn.call (Expr.attrHandle, name.toLowerCase ())?
			fn (elem, name,! documentIsHTML) :
			정의되지 않은;

	return val! == undefined?
		val :
		support.attributes || ! documentIsHTML?
			elem.getAttribute (name) :
			(val = elem.getAttributeNode (name)) && val.specified?
				val.value :
				없는;
};

Sizzle.escape = function (sel) {
	return (sel + "") .replace (rcssescape, fcssescape);
};

Sizzle.error = function (msg) {
	새로운 오류를 던졌습니다 ( "구문 오류, 인식 할 수없는 표현 :"+ msg);
};

/ **
 * 문서 분류 및 중복 제거
 * @param {ArrayLike} 결과
 * /
Sizzle.uniqueSort = 함수 (결과) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// 우리가 중복을 발견 할 수 있다는 것을 알지 못한다면,
	hasDuplicate =! support.detectDuplicates;
	sortInput =! support.sortStable && results.slice (0);
	results.sort (sortOrder);

	if (hasDuplicate) {
		while ((elem = 결과 [i ++])) {
			if (elem === 결과 [i]) {
				j = duplicates.push (i);
			}
		}
		while (j--) {
			results.splice (duplicates [j], 1);
		}
	}

	// 객체를 정렬하기 위해 정렬 한 후 입력 지우기
	// https://github.com/jquery/sizzle/pull/225를 참조하십시오.
	sortInput = null;

	결과를 반환;
};

/ **
 * DOM 노드 배열의 텍스트 값을 검색하기위한 유틸리티 함수
 * @param {배열 | 요소} elem
 * /
getText = Sizzle.getText = function (elem) {
	var 노드,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if (! nodeType) {
		// nodeType이없는 경우 배열로 예상됩니다.
		while ((node ​​= elem [i ++])) {
			// 주석 노드를 탐색하지 않습니다.
			ret + = getText (노드);
		}
	} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
		// 요소에 textContent 사용
		// 새 줄의 일관성을 위해 innerText 사용이 제거되었습니다 (jQuery # 11153).
		if (typeof elem.textContent === "string") {
			return elem.textContent;
		} else {
			// 하위를 탐색합니다.
			for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
				ret + = getText (elem);
			}
		}
	} else if (nodeType === 3 || nodeType === 4) {
		return elem.nodeValue;
	}
	// 주석 또는 처리 명령 노드를 포함하지 않습니다.

	return ret;
};

Expr = Sizzle.selectors = {

	// 사용자가 조정할 수 있음
	cacheLength : 50,

	createPseudo : markFunction,

	일치 : matchExpr,

	attrHandle : {},

	찾기 : {},

	친척 : {
		">": {dir : "parentNode", first : true},
		"": {dir : "parentNode"},
		"+": {dir : "previousSibling", 첫 번째 : true},
		"~": {dir : "previousSibling"}
	},

	preFilter : {
		"ATTR": function (match) {
			match [1] = match [1] .replace (runescape, funescape);

			// 주어진 값을 따옴표 붙이거나 따옴표 붙이지 않고 [3]으로 이동시킵니다.
			match [3] = (match [3] || match [4] || match [5] || "") .replace (runescape, funescape);

			if (match [2] === "~ =") {
				match [3] = ""+ match [3] + "";
			}

			return match.slice (0, 4);
		},

		"아동": 기능 (일치) {
			/ * matchExpr의 일치 항목 [ "CHILD"]
				1 유형 (만 | nth | ...)
				2 what (자식 | of-type)
				3 인수 (even | odd | \ d * | \ d * n ([+ -] \ d +)? ... ...)
				xn + y 인수의 xn-component ([+ -]? \ d * n |)
				xn- 성분의 5 부호
				xn 성분의 6 x
				y- 성분의 7 부호
				y 성분의 8 y
			* /
			match [1] = match [1] .toLowerCase ();

			if (match [1] .slice (0, 3) === "nth") {
				// nth- *는 인수가 필요합니다.
				if (! match [3]) {
					Sizzle.error (match [0]);
				}

				// Expr.filter.CHILD에 대한 숫자 x 및 y 매개 변수
				// false / true 캐스팅을 각각 0/1로 저장합니다.
				match [3] === "even"|| match [3] === "match"[4] = + "match" 이상한 "));
				match [5] = + ((match [7] + match [8]) || match [3] === "odd");

			// 다른 형식은 인수를 금지합니다.
			} else if (match [3]) {
				Sizzle.error (match [0]);
			}

			리턴 매치;
		},

		"PSEUDO": function (match) {
			var 초과,
				unquoted =! match [6] && match [2];

			if (matchExpr [ "CHILD"]. test (match [0])) {
				null를 돌려 준다.
			}

			// 인용 된 인수를 그대로 받아들입니다.
			if (match [3]) {
				match [2] = match [4] || 경기 [5] || "";

			// 인용되지 않은 인수에서 초과 문자를 제거합니다.
			} else if (unquoted && rpseudo.test (따옴표 제외)) &&
				// 토큰 화에서 초과를 얻는다 (재귀 적으로)
				(초과 = 토큰 화 (인용되지 않은, 참)) &&
				// 다음 닫는 괄호로 이동
				(인용 부호없는. 인용 부호없는 길이.) - 인용 부호없는. 길이)) {

				// 초과는 음수 인덱스입니다.
				match [0] = match [0] .slice (0, 초과);
				match [2] = unquoted.slice (0, 초과);
			}

			// 의사 필터 메서드 (유형 및 인수)에 필요한 캡처 만 반환합니다.
			return match.slice (0, 3);
		}
	},

	필터 : {

		"TAG": function (nodeNameSelector) {
			var nodeName = nodeNameSelector.replace (runescape, funescape) .toLowerCase ();
			return nodeNameSelector === "*"?
				function () {true를 반환; } :
				함수 (elem) {
					return elem.nodeName && elem.nodeName.toLowerCase () === nodeName;
				};
		},

		"CLASS": function (className) {
			var pattern = classCache [className + ""];

			반환 패턴 ||
				(패턴 = 새 RegExp ( "(^ |"+ 공백 + ")"+ className + "("+ 공백 + "| $)")) &&
				classCache (className, function (elem) {
					return pattern.test (typeof elem.className === "string"&& elem.className || typeof elem.getAttribute! == "undefined"&& elem.getAttribute ( "class") || "");
				});
		},

		"ATTR": 기능 (이름, 운영자, 수표) {
			반환 함수 (elem) {
				var result = Sizzle.attr (elem, name);

				if (result == null) {
					return operator === "! =";
				}
				if (! 연산자) {
					참을 돌려라.
				}

				결과 + = "";

				return operator === "="? 결과 === 확인 :
					연산자 === "! ="? 결과! == 확인 :
					연산자 === "^ ="? 확인 && result.indexOf (확인) === 0 :
					연산자 === "* ="? && result.indexOf (check)> -1을 확인하십시오.
					연산자 === "$ ="? && result.slice (-check.length) === 확인 :
					연산자 === "~ ="? ( "+ result.replace (rwhitespace," ") +" ") .indexOf (check)> -1 :
					연산자 === "| ="? 결과 === 확인 || result.slice (0, check.length + 1) === check + "-":
					그릇된;
			};
		},

		"CHILD": function (type, what, argument, first, last) {
			var simple = type.slice (0, 3)! == "nth",
				forward = type.slice (-4)! == "last",
				ofType = what === "of-type";

			첫 번째 반환 === 1 && last === 0?

				// 단축키 : nth - * (n)
				함수 (elem) {
					return !! elem.parentNode;
				} :

				함수 (elem, context, xml) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple! == 앞으로? "nextSibling": "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase (),
						useCache =! xml &&! ofType,
						diff = false;

					if (parent) {

						// : (첫 번째 | 마지막 | 만) - (자식 | of-type)
						if (simple) {
							동안 (dir) {
								노드 = elem;
								while ((node ​​= node [dir])) {
									if (ofType?
										node.nodeName.toLowerCase () === name :
										node.nodeType === 1) {

										false를 반환;
									}
								}
								// 반대 방향 : only- * (아직 수행하지 않은 경우)
								start = dir = type === "only"&&! start && "nextSibling";
							}
							참을 돌려라.
						}

						시작 = [앞으로? parent.firstChild : parent.lastChild];

						// non-xml : nth-child (...)는 캐시 데이터를`parent`에 저장합니다.
						if (forward && useCache) {

							// 이전에 캐시 된 인덱스에서`elem`을 찾는다.

							// ... gzip에 친숙한 방식으로
							노드 = 부모;
							outerCache = 노드 [expando] || (노드 [expando] = {});

							// 지원 : IE <9 만
							// 복제 된 애트리뷰트에 대한 방어 (jQuery gh-1709)
							uniqueCache = outerCache [node.uniqueID] ||
								(outerCache [node.uniqueID] = {});

							cache = uniqueCache [type] || [];
							nodeIndex = 캐시 [0] === dirruns && 캐시 [1];
							diff = nodeIndex && cache [2];
							node = nodeIndex && parent.childNodes [nodeIndex];

							while ((node ​​= ++ nodeIndex && node && node [dir] ||

								// 처음부터`elem`을 찾는데 실패했다.
								(diff = nodeIndex = 0) || start.pop ())) {

								// 발견되면,`parent`에 인덱스를 캐쉬 해, break
								if (node.nodeType === 1 && ++ diff && node === elem) {
									uniqueCache [type] = [dirruns, nodeIndex, diff];
									단절;
								}
							}

						} else {
							// 사용 가능한 경우 이전에 캐싱 된 요소 인덱스를 사용합니다.
							if (useCache) {
								// ... gzip에 친숙한 방식으로
								노드 = elem;
								outerCache = 노드 [expando] || (노드 [expando] = {});

								// 지원 : IE <9 만
								// 복제 된 애트리뷰트에 대한 방어 (jQuery gh-1709)
								uniqueCache = outerCache [node.uniqueID] ||
									(outerCache [node.uniqueID] = {});

								cache = uniqueCache [type] || [];
								nodeIndex = 캐시 [0] === dirruns && 캐시 [1];
								diff = nodeIndex;
							}

							// xml : nth-child (...)
							// 또는 : nth-last-child (...) 또는 : nth (-last)? of-type (...)
							if (diff === false) {
								// 위와 같은 루프를 사용하여 시작 부분에서`elem`을 찾는다.
								while ((node ​​= ++ nodeIndex && node && node [dir] ||
									(diff = nodeIndex = 0) || start.pop ())) {

									if ((ofType?
										node.nodeName.toLowerCase () === name :
										node.nodeType === 1) &&
										++ diff) {

										// 각 요소의 색인을 캐시합니다.
										if (useCache) {
											outerCache = 노드 [expando] || (노드 [expando] = {});

											// 지원 : IE <9 만
											// 복제 된 애트리뷰트에 대한 방어 (jQuery gh-1709)
											uniqueCache = outerCache [node.uniqueID] ||
												(outerCache [node.uniqueID] = {});

											uniqueCache [type] = [dirruns, diff];
										}

										if (node ​​=== elem) {
											단절;
										}
									}
								}
							}
						}

						// 오프셋을 통합 한 다음 사이클 크기를 확인합니다.
						diff - = 마지막;
						return diff === first || (diff % first === 0 && diff / first> = 0);
					}
				};
		},

		"PSEUDO": function (의사, 인수) {
			// 의사 클래스 이름은 대소 문자를 구별하지 않습니다.
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// 대문자로 사용자 지정 의사가 추가되는 경우 대 / 소문자 구분 우선 순위 지정
			// setFilters는 가상으로부터 상속받습니다.
			var args,
				fn = Expr.pseudos [의사] || Expr.setFilters [pseudo.toLowerCase ()] ||
					Sizzle.error ( "지원되지 않는 의사 :"+ 의사);

			// 사용자는 createPseudo를 사용하여
			// 필터 함수를 만들려면 인수가 필요합니다.
			// Sizzle처럼
			if (fn [expando]) {
				return fn (인수);
			}

			// 이전 서명에 대한 지원을 유지합니다.
			if (fn.length> 1) {
				args = [의사, 의사, "", 인수];
				return Expr.setFilters.hasOwnProperty (pseudo.toLowerCase ())?
					markFunction (함수 (시드, 일치) {
						var idx,
							일치 = fn (시드, 인수),
							i = matched.length;
						while (i--) {
							idx = indexOf (seed, matched [i]);
							시드 [idx] =! ([idx] = matched [i]와 일치);
						}
					}) :
					함수 (elem) {
						return fn (elem, 0, args);
					};
			}

			fn을 반환;
		}
	},

	의사 : {
		// 잠재적으로 복잡한 의사
		"not": markFunction (function (selector) {
			// 컴파일러로 전달 된 selector를 다듬습니다.
			// 선행 및 후행 처리를 피하기 위해
			// 연결자로 공백
			var input = [],
				결과 = [],
				matcher = compile (selector.replace (rtrim, "$ 1"));

			반환 matcher [expando]?
				markFunction (함수 (시드, 일치, 컨텍스트, xml) {
					var elem,
						비교할 수없는 = 일치 자 (seed, null, xml, []),
						i = seed.length;

					// 'matcher'와 일치하지 않는 요소 매치
					while (i--) {
						if ((elem = 일치하지 않는 [i])) {
							seed [i] =! (matches [i] = elem);
						}
					}
				}) :
				함수 (elem, context, xml) {
					입력 [0] = elem;
					matcher (입력, null, xml, 결과);
					// 요소를 유지하지 않음 (이슈 # 299)
					입력 [0] = null;
					return! results.pop ();
				};
		}),

		"has": markFunction (function (selector) {
			반환 함수 (elem) {
				return Sizzle (selector, elem) .length> 0;
			};
		}),

		"contains": markFunction (function (text) {
			text = text.replace (runescape, funescape);
			반환 함수 (elem) {
				return (elem.textContent || elem.innerText || getText (elem)) .indexOf (text)> -1;
			};
		}),

		// "요소가 a : lang () 선택자로 표현되는지 여부
		// 요소의 언어 값만을 기반으로합니다.
		// 식별자 C와 같음,
		// 식별자 C로 시작하여 바로 뒤에 "-"가옵니다.
		// 요소의 언어 값에 대한 C의 일치는 대소 문자를 구분하지 않고 수행됩니다.
		// 식별자 C는 유효한 언어 이름 일 필요는 없습니다. "
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction (function (lang) {
			// lang 값은 유효한 식별자 여야합니다.
			if (! ridentifier.test (lang || "")) {
				Sizzle.error ( "지원되지 않는 lang :"+ lang);
			}
			lang = lang.replace (runescape, funescape) .toLowerCase ();
			반환 함수 (elem) {
				var elemLang;
				할;
					if ((elemLang = documentIsHTML?
						elem.lang :
						elem.getAttribute ( "xml : lang") || elem.getAttribute ( "lang"))) {

						elemLang = elemLang.toLowerCase ();
						return elemLang === lang || elemLang.indexOf (lang + "-") === 0;
					}
				} while ((elem = elem.parentNode) && elem.nodeType === 1);
				false를 반환;
			};
		}),

		// 기타
		"target": function (elem) {
			var hash = window.location && window.location.hash;
			해시를 반환 && hash.slice (1) === elem.id;
		},

		"루트": function (elem) {
			return elem === docElem;
		},

		"focus": function (elem) {
			return elem === document.activeElement && (! document.hasFocus || document.hasFocus ()) && !! (elem.type || elem.href || ~ elem.tabIndex);
		},

		// 부울 속성
		"enabled": createDisabledPseudo (false),
		"disabled": createDisabledPseudo (true),

		"checked": function (elem) {
			// CSS3에서 : checked는 checked 요소와 selected 요소를 모두 반환해야합니다.
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase ();
			return (nodeName === "input"&& !! elem.checked) || (nodeName === "option"&& !! elem.selected);
		},

		"selected": function (elem) {
			//이 속성에 액세스하면 기본적으로 선택됩니다.
			// Safari의 옵션이 제대로 작동합니다.
			if (elem.parentNode) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// 내용
		"empty": function (elem) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// : empty는 요소 (1) 또는 내용 노드 (텍스트 : 3, cdata : 4, 엔티티 참조 : 5)에 의해 무효화됩니다.
			// 다른 사람이 아닌 (주석 : 8, 처리 명령 : 7 등)
			속성 (2)이 자식으로 나타나지 않기 때문에 // nodeType <6이 작동합니다.
			for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
				if (elem.nodeType <6) {
					false를 반환;
				}
			}
			참을 돌려라.
		},

		"parent": function (elem) {
			return! Expr.pseudos [ "empty"] (elem);
		},

		// 요소 / 입력 유형
		"header": function (elem) {
			return rheader.test (elem.nodeName);
		},

		"입력": function (elem) {
			return rinputs.test (elem.nodeName);
		},

		"버튼": function (elem) {
			var name = elem.nodeName.toLowerCase ();
			return name === "input"&& elem.type === "button"|| 이름 === "버튼";
		},

		"텍스트": function (elem) {
			var attr;
			return elem.nodeName.toLowerCase () === "input"&&
				elem.type === "text"&&

				// 지원 : IE <8
				// 새로운 HTML5 속성 값 (예 : "search")은 elem.type === "text"와 함께 나타납니다.
				((attr = elem.getAttribute ( "type")) == null || attr.toLowerCase () === "text");
		},

		// 컬렉션 위치 지정
		"첫 번째": createPositionalPseudo (function () {
			return [0];
		}),

		"마지막": createPositionalPseudo (function (matchIndexes, length) {
			return [길이 - 1];
		}),

		"eq": createPositionalPseudo (function (matchIndexes, length, argument) {
			return [인수 <0? 인수 + 길이 : 인수];
		}),

		"even": createPositionalPseudo (function (matchIndexes, length) {
			var i = 0;
			for (; i <길이; i + = 2) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"홀수": createPositionalPseudo (function (matchIndexes, length) {
			var i = 1;
			for (; i <길이; i + = 2) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo (function (matchIndexes, length, argument) {
			var i = 인수 <0? 인수 + 길이 : 인수;
			for (; - i> = 0;) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo (function (matchIndexes, length, argument) {
			var i = 인수 <0? 인수 + 길이 : 인수;
			for (; ++ i <길이;) {
				matchIndexes.push (i);
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos [ "nth"] = Expr.pseudos [ "eq"];

// 버튼 / 입력 유형 의사를 추가합니다.
({radio : true, checkbox : true, file : true, password : true, image : true}) {
	Expr.pseudos [i] = createInputPseudo (i);
}
for (i {in : true, reset : true}) {
	Expr.pseudos [i] = createButtonPseudo (i);
}

// 새로운 setFilters를 생성하기위한 쉬운 API
function setFilters () {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = 새로운 setFilters ();

tokenize = Sizzle.tokenize = function (selector, parseOnly) {
	var 일치, 일치, 토큰, 유형,
		soFar, groups, preFilters,
		cached = tokenCache [selector + ""];

	if (캐시 된) {
		parseOnly를 돌려 주시겠습니까? 0 : cached.slice (0);
	}

	soFar = 선택자;
	groups = [];
	preFilters = Expr.preFilter;

	while (soFar) {

		// 쉼표 및 첫 번째 실행
		if (! matches || (match = rcomma.exec (soFar))) {
			if (match) {
				// 후행 쉼표를 유효한 것으로 사용하지 않습니다.
				soFar = soFar.slice (match [0] .length) || 지금까지;
			}
			groups.push (토큰 = []));
		}

		일치 = 거짓;

		// Combinators
		if ((match = rcombinators.exec (soFar))) {
			matched = match.shift ();
			tokens.push ({
				값 : 일치 함,
				// 자손 결합자를 공간에 캐스트
				type : match [0] .replace (rtrim, "")
			});
			soFar = soFar.slice (matched.length);
		}

		// 필터
		for (Expr.filter에서 입력) {
			if ((match = matchExpr [type] .exec (soFar)) && (! preFilters [type] ||
				(match = preFilters [type] (match)))) {
				matched = match.shift ();
				tokens.push ({
					값 : 일치 함,
					유형 : 유형,
					성냥 : 성냥
				});
				soFar = soFar.slice (matched.length);
			}
		}

		if (! matches) {
			단절;
		}
	}

	// 유효하지 않은 초과 길이를 반환합니다.
	// 구문 분석 만하는 경우
	// 그렇지 않으면 오류를 던지거나 토큰을 반환합니다.
	parseOnly를 돌려 주시겠습니까?
		soFar.length :
		지금까지 ?
			Sizzle.error (selector) :
			// 토큰 캐시하기
			tokenCache (셀렉터, 그룹). 슬라이스 (0);
};

function toSelector (토큰) {
	var i = 0,
		len = 토큰. 길이,
		selector = "";
	for (; i <len; i ++) {
		selector + = 토큰 [i]. 값;
	}
	반환 선별 자;
}

function addCombinator (matcher, combinator, base) {
	var dir = combinator.dir,
		skip = combinator.next,
		키 = 건너 뛰기 || 각하,
		checkNonElements = 기본 && 키 === "parentNode",
		doneName = 완료 ++;

	combinator.first를 돌려 주시겠습니까?
		// 가장 가까운 조상 / 선행 요소를 검사합니다.
		함수 (elem, context, xml) {
			while ((elem = elem [dir])) {
				if (elem.nodeType === 1 || checkNonElements) {
					return matcher (elem, context, xml);
				}
			}
			false를 반환;
		} :

		// 모든 조상 / 선행 요소를 검사합니다.
		함수 (elem, context, xml) {
			var oldCache, uniqueCache, outerCache,
				newCache = [dirruns, doneName];

			// XML 노드에서 임의의 데이터를 설정할 수 없기 때문에 결합 자 캐싱을 사용하지 않아도됩니다.
			if (xml) {
				while ((elem = elem [dir])) {
					if (elem.nodeType === 1 || checkNonElements) {
						if (matcher (elem, context, xml)) {
							참을 돌려라.
						}
					}
				}
			} else {
				while ((elem = elem [dir])) {
					if (elem.nodeType === 1 || checkNonElements) {
						outerCache = elem [expando] || (elem [expando] = {});

						// 지원 : IE <9 만
						// 복제 된 애트리뷰트에 대한 방어 (jQuery gh-1709)
						uniqueCache = outerCache [elem.uniqueID] || (outerCache [elem.uniqueID] = {});

						if (건너 뛰기 && 건너 뛰기 === elem.nodeName.toLowerCase ()) {
							elem = elem [dir] || 엘름;
						} else if ((oldCache = uniqueCache [key]) &&
							oldCache [0] === dirruns && oldCache [1] === doneName) {

							// 결과를 이전 요소로 역 전파하도록 newCache에 지정
							return (newCache [2] = oldCache [2]);
						} else {
							// 결과가 이전 요소로 역 전파 할 수 있도록 newcache 재사용
							uniqueCache [key] = newCache;

							// 일치한다는 것은 완료되었음을 의미합니다. 실패 란 우리가 계속 점검해야한다는 것을 의미한다.
							if ((newCache [2] = matcher (elem, context, xml))) {
								참을 돌려라.
							}
						}
					}
				}
			}
			false를 반환;
		};
}

function elementMatcher (matchers) {
	리턴 matchers.length> 1?
		함수 (elem, context, xml) {
			var i = matchers.length;
			while (i--) {
				if (! matchers [i] (elem, context, xml)) {
					false를 반환;
				}
			}
			참을 돌려라.
		} :
		matchers [0];
}

function multipleContexts (선택자, 컨텍스트, 결과) {
	var i = 0,
		len = contexts.length;
	for (; i <len; i ++) {
		지글 거리기 (선택기, 컨텍스트 [i], 결과);
	}
	결과를 반환;
}

함수 응축 (타의 추종을 불허하는지도, 필터, 문맥, xml) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = 일치하지 않습니다. 길이,
		mapped = map! = null;

	for (; i <len; i ++) {
		if ((elem = 일치하지 않는 [i])) {
			if (! filter || filter (elem, context, xml)) {
				newUnmatched.push (elem);
				if (mapped) {
					map.push (i);
				}
			}
		}
	}

	return newUnmatched;
}

함수 setMatcher (preFilter, selector, matcher, postFilter, postFinder, postSelector) {
	if (postFilter &&! postFilter [expando]) {
		postFilter = setMatcher (postFilter);
	}
	if (postFinder &&! postFinder [expando]) {
		postFinder = setMatcher (postFinder, postSelector);
	}
	return markFunction (function (seed, 결과, 컨텍스트, xml)) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// 시드 또는 컨텍스트에서 초기 요소 가져 오기
			elems = 씨앗 || multipleContexts (selector || "*", context.nodeType? [context] : 컨텍스트, []),

			// 시드 (seed) 결과 동기화를위한 맵을 유지하면서 정규 입력을 얻는 프리 필터
			matcherIn = preFilter && (seed ||! selector)?
				condense (elems, preMap, preFilter, context, xml) :
				elems,

			matcherOut = matcher?
				// postFinder 또는 필터링 된 시드 또는 비 시드 postFilter 또는 기존 결과가있는 경우,
				포스트 파인더 || (seed? preFilter : preexisting || postFilter)?

					// ... 중간 처리가 필요합니다.
					[] :

					// ... 그렇지 않으면 결과를 직접 사용합니다.
					결과 :
				matcherIn;

		// 기본 일치 항목 찾기
		if (matcher) {
			정규식 (matcherIn, matcherOut, context, xml);
		}

		// postFilter를 적용합니다.
		if (postFilter) {
			임시 = 집계 (matcherOut, postMap);
			postFilter (임시, [], 컨텍스트, xml);

			// 실패한 요소를 다시 matcherIn으로 이동하여 일치하지 않는 요소를 찾습니다.
			i = temp.length;
			while (i--) {
				if ((elem = temp [i])) {
					matcherOut [postMap [i]] =! (matcherIn [postMap [i]] = elem);
				}
			}
		}

		if (시드) {
			if (postFinder || preFilter) {
				if (postFinder) {
					//이 중간을 postFinder 컨텍스트로 축소하여 최종 matcherOut을 가져옵니다.
					임시 = [];
					i = matcherOut.length;
					while (i--) {
						if ((elem = matcherOut [i])) {
							// elem이 아직 최종 일치하지 않기 때문에 matcherIn을 복원하십시오.
							temp.push ((matcherIn [i] = elem));
						}
					}
					postFinder (null, (matcherOut = []), temp, xml);
				}

				// 일치 된 요소를 시드에서 결과로 이동하여 동기화 유지
				i = matcherOut.length;
				while (i--) {
					if ((elem = matcherOut [i]) &&
						(temp = postFinder? indexOf (seed, elem) : preMap [i])> -1) {

						seed [temp] =! (결과 [임시] = elem);
					}
				}
			}

		// 정의 된 경우 postFinder를 통해 결과에 요소 추가
		} else {
			matcherOut = 응축 (
				matcherOut === 결과?
					matcherOut.splice (기존, matcherOut.length) :
					matcherOut
			);
			if (postFinder) {
				postFinder (null, results, matcherOut, xml);
			} else {
				push.apply (결과, matcherOut);
			}
		}
	});
}

function matcherFromTokens (토큰) {
	var checkContext, matcher, j,
		len = 토큰. 길이,
		leadingRelative = Expr.relative [토큰 [0]. 유형],
		implicitRelative = leadingRelative || Expr.relative [ ""],
		i = leadingRelative? 1 : 0,

		// 기본 matcher는 최상위 컨텍스트에서 요소에 도달 할 수 있는지 확인합니다.
		matchContext = addCombinator (function (elem) {
			return elem === checkContext;
		}, implicitRelative, true),
		matchAnyContext = addCombinator (function (elem) {
			return indexOf (checkContext, elem)> -1;
		}, implicitRelative, true),
		matchers = [함수 (elem, context, xml) {
			var ret = (! leadingRelative && (xml || context! == outermostContext)) || (
				(checkContext = context) .nodeType?
					matchContext (elem, context, xml) :
					matchAnyContext (elem, context, xml));
			// 요소에 매달리지 않음 (문제 # 299)
			checkContext = null;
			return ret;
		}];

	for (; i <len; i ++) {
		if ((matcher = Expr.relative [tokens [i] .type])) {
			matchers = [addCombinator (elementMatcher (matchers), matcher)];
		} else {
			matcher = Expr.filter [tokens [i] .type] .apply (null, tokens [i] .matches);

			// 위치 일치를 보면서 특별 반환
			if (matcher [expando]) {
				// 적절한 처리를 위해 다음 상대 연산자 (있는 경우)를 찾습니다.
				j = ++ i;
				for (; j <len; j ++) {
					if (Expr.relative [tokens [j] .type)) {
						단절;
					}
				}
				return setMatcher (
					i> 1 && elementMatcher (matchers),
					i> 1 && toSelector (
						// 앞의 토큰이 자손 결합자인 경우 암시 적 any-element`*`
						tokens.slice (0, i - 1) .concat ({value : 토큰 [i - 2] .type === ""? "": ""})
					) .replace (rtrim, "$ 1"),
					일치,
					i <j && matcherFromTokens (tokens.slice (i, j)),
					j <len && matcherFromTokens ((tokens = tokens.slice (j))),
					j <len && toSelector (토큰)
				);
			}
			matchers.push (matcher);
		}
	}

	return elementMatcher (matchers);
}

function matcherFromGroupMatchers (elementMatchers, setMatchers) {
	var bySet = setMatchers.length> 0,
		byElement = elementMatchers.length> 0,
		superMatcher = function (시드, 컨텍스트, xml, 결과, 가장 바깥 쪽) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				일치하지 않는 = 시드 && [],
				setMatched = [],
				contextBackup = 가장 바깥 쪽의 컨텍스트,
				// 우리는 항상 시드 요소 또는 가장 바깥 쪽의 컨텍스트를 가져야합니다.
				elems = 씨앗 || byElement && Expr.find [ "TAG"] ( "*", 가장 바깥 쪽),
				// 이것이 가장 바깥 쪽의 matcher 인 경우에 정수 dirrun을 사용한다.
				dirrunsUnique = (dirruns + = contextBackup == null? 1 : Math.random () || 0.1),
				len = elems.length;

			if (가장 바깥 쪽) {
				outermostContext = 컨텍스트 === 문서 || 문맥 || 가장 바깥 쪽;
			}

			// 결과에 elementMatchers를 직접 전달하는 요소 추가
			// 지원 : IE <9, Safari
			// id에 일치하는 NodeList 속성 (IE : "length"; Safari : <number>)을 허용합니다.
			for (; i! == len && (elem = elems [i])! = null; i ++) {
				if (byElement && elem) {
					j = 0;
					if (! context && elem.ownerDocument! == document) {
						setDocument (elem);
						xml =! documentIsHTML;
					}
					while ((matcher = elementMatchers [j ++])) {
						if (matcher (elem, context || document, xml)) {
							results.push (elem);
							단절;
						}
					}
					if (가장 바깥 쪽) {
						dirruns = dirrunsUnique;
					}
				}

				// 설정 필터에 일치하지 않는 요소를 추적합니다.
				if (bySet) {
					// 그들은 모든 가능한 matchers를 통과했을 것이다.
					if ((elem =! matcher && elem)) {
						matchedCount--;
					}

					// 매치 된 엘리먼트 또는 매치 된 엘리먼트에 대해 배열을 길게한다.
					if (시드) {
						unmatched.push (elem);
					}
				}
			}

			// 'i`는 위에서 방문한 요소의 수이며,`matchedCount`에 추가합니다.
			// 후자를 음수가 아닌 값으로 만듭니다.
			matchedCount + = i;

			// 일치하지 않는 요소에 설정된 필터 적용
			// 참고 : 일치하지 않는 요소가 없으면 건너 뛸 수 있습니다 (예 :`matchedCount`
			// 위와 같음), 우리는 위의 루프에서 _any_ 요소를 방문하지 않았다면
			// 원소 matcher와 seed가 없다.
			// 처음 문자열 "0"을 증가 시킴`i`는`i`가 그 안에 문자열 만 남도록합니다.
			// case는`i`와는 다른 "00"의`matchedCount`를 발생 시키지만 또한
			// 숫자로 0입니다.
			if (bySet && i! == matchedCount) {
				j = 0;
				while ((matcher = setMatchers [j ++])) {
					매처 (타의 추종을 불허하는, setMatched, context, xml);
				}

				if (시드) {
					// 요소를 다시 매치하여 정렬 필요성 제거
					if (matchedCount> 0) {
						while (i--) {
							if (! (일치하지 않는 [i] || setMatched [i])) {
								setMatched [i] = pop.call (results);
							}
						}
					}

					// 실제 일치 항목 만 가져 오기 위해 인덱스 자리 표시 자 값을 무시합니다.
					setMatched = 집계 (setMatched);
				}

				// 결과에 일치 항목 추가
				push.apply (results, setMatched);

				// 정렬을 규정하는 여러 개의 성공적인 matchers에 이어지는 시드없는 세트 일치
				if (가장 바깥 쪽 &&! seed && setMatched.length> 0 &&
					(matchedCount + setMatchers.length)> 1) {

					Sizzle.uniqueSort (결과);
				}
			}

			// 중첩 된 matcher를 사용하여 전역의 조작을 덮어 씁니다.
			if (가장 바깥 쪽) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			타의 추종을 불허하는 반환;
		};

	Return bySet?
		markFunction (superMatcher) :
		슈퍼 매처;
}

compile = Sizzle.compile = function (selector, match / * 내부 전용 * /) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache [selector + ""];

	if (! cached) {
		// 각 요소를 검사하는 데 사용할 수있는 재귀 함수의 함수 생성
		if (! match) {
			match = tokenize (selector);
		}
		i = match.length;
		while (i--) {
			cached = matcherFromTokens (match [i]);
			if (캐시 된 [expando]) {
				setMatchers.push (캐시 된);
			} else {
				elementMatchers.push (캐시 된);
			}
		}

		// 컴파일 된 함수를 캐시하십시오.
		캐시 된 = compilerCache (선택기, matcherFromGroupMatchers (elementMatchers, setMatchers));

		// 셀렉터 및 토큰 화 저장
		cached.selector = selector;
	}
	캐시 된 반환;
};

/ **
 * Sizzle의 컴파일과 함께 작동하는 저수준 선택 기능
 * 선택기 함수
 * @param {String | Function} selector selector 또는 미리 컴파일 된
 * Sizzle.compile로 빌드 된 선택기 함수
 * @param {Element} 컨텍스트
 * @param {배열} [결과]
 * @param {Array} [seed] 일치시킬 요소 집합입니다.
 * /
select = Sizzle.select = function (선택자, 컨텍스트, 결과, 시드) {
	var i, 토큰, 토큰, 유형, 찾기,
		컴파일 된 = typeof selector === "function"&& selector,
		match =! seed && tokenize ((selector = compiled.selector || selector));

	결과 = 결과 || [];

	// 목록에 셀렉터가 하나 뿐이고 시드가없는 경우 작업을 최소화하려고합니다.
	// (후자는 우리에게 상황을 보장 함)
	if (match.length === 1) {

		// leading 컴파운드 선택자가 ID 인 경우 컨텍스트를 줄입니다.
		토큰 = 일치 [0] = 일치 [0]. 슬라이스 (0);
		if (tokens.length> 2 && (token = tokens [0]). type === "ID"&&
				context.nodeType === 9 && documentIsHTML && Expr.relative [토큰 [1] .type]) {

			context = (Expr.find [ "ID"] (token.matches [0] .replace (runescape, funescape), context) || []) [0];
			if (! context) {
				결과를 반환;

			// 미리 컴파일 된 matchers는 여전히 조상을 확인하므로 레벨을 올리십시오.
			} else if (컴파일 된) {
				context = context.parentNode;
			}

			selector = selector.slice (tokens.shift (). value.length);
		}

		// 오른쪽에서 왼쪽으로 일치하는 시드 집합 가져 오기
		i = matchExpr [ "needsContext"]. test (selector)? 0 : 토큰. 길이;
		while (i--) {
			토큰 = 토큰 [i];

			// 우리가 연결자를 쳤다면 중단한다.
			if (Expr.relative [(type = token.type)]) {
				단절;
			}
			if ((find = Expr.find [type])) {
				// 형제 중재자의 컨텍스트를 검색하고 확장합니다.
				if ((seed = find (
					token.matches [0] .replace (runescape, funescape),
					rsibling.test (토큰 [0] .type) && testContext (context.parentNode) || 문맥
				)))) {

					// 시드가 비어 있거나 토큰이 남아 있지 않으면 조기에 반환 할 수 있습니다.
					tokens.splice (i, 1);
					selector = seed.length && toSelector (토큰);
					if (! selector) {
						push.apply (결과, 시드);
						결과를 반환;
					}

					단절;
				}
			}
		}
	}

	// 필터링 함수가 제공되지 않은 경우 컴파일하고 실행합니다.
	// 위의 selector를 수정하면 retokenization을 피하기 위해`match`를 제공합니다.
	(컴파일 된 || 컴파일러 (선택자, 일치)) (
		씨,
		문맥,
		! documentIsHTML,
		결과,
		컨텍스트 || rsibling.test (selector) && testContext (context.parentNode) || 문맥
	);
	결과를 반환;
};

// 일회성 과제

// 정렬 안정성
support.sortStable = expando.split ( ""). sort (sortOrder) .join ( "") === expando;

// 지원 : Chrome 14-35 +
// 비교 함수에 전달되지 않으면 항상 중복을 가정합니다.
support.detectDuplicates = !! hasDuplicate;

// 기본 문서에 대해 초기화합니다.
setDocument ();

// 지원 : Webkit <537.32 - Safari 6.0.3 / Chrome 25 (Chrome 27에서 수정 됨)
// 분리 된 노드가 혼란스럽게 * 따라 가게 *
support.sortDetached = assert (function (el) {
	// 1을 반환해야하지만 4를 반환합니다 (다음).
	return el.compareDocumentPosition (document.createElement ( "fieldset")) & 1;
});

// 지원 : IE <8
// 속성 / 속성 "interpolation"방지
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if (! assert (function (el) {
	el.innerHTML = "<a href='#'> </a>";
	return el.firstChild.getAttribute ( "href") === "#";
})) {
	addHandle ( "type | href | height | width", function (elem, name, isXML) {
		if (! isXML) {
			return elem.getAttribute (name, name.toLowerCase () === "type"? 1 : 2);
		}
	});
}

// 지원 : IE <9
// getAttribute ( "value") 대신 defaultValue를 사용합니다.
if (! support.attributes ||! assert (function (el) {
	el.innerHTML = "<input />";
	el.firstChild.setAttribute ( "value", "");
	return el.firstChild.getAttribute ( "value") === "";
})) {
	addHandle ( "value", function (elem, name, isXML) {
		if (! isXML && elem.nodeName.toLowerCase () === "input") {
			return elem.defaultValue;
		}
	});
}

// 지원 : IE <9
// getAttributeNode를 사용하여 getAttribute가 거짓 일 때 부울 값 가져 오기
if (! assert (function (el) {
	return el.getAttribute ( "disabled") == null;
})) {
	addHandle (boolean, function (elem, name, isXML)) {
		var val;
		if (! isXML) {
			return elem [name] === true? name.toLowerCase () :
					(val = elem.getAttributeNode (name)) && val.specified?
					val.value :
				없는;
		}
	});
}

Sizzle을 돌려 보내라.

})( 창문 );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// 사용되지 않음
jQuery.expr [ ":"] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function (elem, dir, until) {
	var matched = [],
		truncate = until! == undefined;

	while ((elem = elem [dir]) && elem.nodeType! == 9) {
		if (elem.nodeType === 1) {
			if (truncate && jQuery (elem) .is (until)) {
				단절;
			}
			matched.push (elem);
		}
	}
	반환 일치;
};


var 형제 = 함수 (n, elem) {
	var matched = [];

	for (; n; n = n.nextSibling) {
		if (n.nodeType === 1 && n! == elem) {
			matched.push (n);
		}
	}

	반환 일치;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName (elem, name) {

  return elem.nodeName && elem.nodeName.toLowerCase () === name.toLowerCase ();

};
* \ [\ x20 \ t \ r \ n \ f] * \ /?> (var / rsingleTag = (/ ^ < ? : <\ / \ 1> |) $ / i);



// filter와 not에 동일한 기능을 구현합니다.
함수 winnow (엘레멘트, 한정어, not) {
	if (isFunction (qualifier))) {
		return jQuery.grep (elements, function (elem, i) {
			return !! qualifier.call (elem, i, elem)! == 아닙니다;
		});
	}

	// 단일 요소
	if (qualifier.nodeType) {
		return jQuery.grep (elements, function (elem) {
			return (elem === 한정자)! == not;
		});
	}

	// 요소의 Arraylike (jQuery, arguments, Array)
	if (한정자 typeof! == "문자열") {
		return jQuery.grep (elements, function (elem) {
			return (indexOf.call (qualifier, elem)> -1)! == not;
		});
	}

	// 단순 선택기와 복합 선택기 모두에 대해 직접 필터링
	return jQuery.filter (한정자, 요소, 아닌);
}

jQuery.filter = function (expr, elems, not) {
	var elem = elems [0];

	if (not) {
		expr = ": not ("+ expr + ")";
	}

	if (elems.length === 1 && elem.nodeType === 1) {
		return jQuery.find.matchesSelector (elem, expr)? [elem] : [];
	}

	return jQuery.find.matches (expr, jQuery.grep (elems, function (elem) {
		return elem.nodeType === 1;
	})));
};

jQuery.fn.extend ({
	찾기 : function (selector) {
		var i, ret,
			len = this.length,
			자기 =이;

		if (typeof selector! == "string") {
			반환 this.pushStack (jQuery (selector) .filter (function () {
				for (i = 0; i <len; i ++) {
					if (jQuery.contains (self [i], this))) {
						참을 돌려라.
					}
				}
			})));
		}

		ret = this.pushStack ([]);

		for (i = 0; i <len; i ++) {
			jQuery.find (selector, self [i], ret);
		}

		len> 1을 반환합니까? jQuery.uniqueSort (ret) : ret;
	},
	필터 : function (selector) {
		this.pushStack (winnow (this, selector || [], false)) this를 반환합니다.
	},
	아니요 : function (selector) {
		this.pushStack (winnow (this, selector || [], true)) this를 반환합니다.
	},
	is : function (selector) {
		돌아오다!
			이,

			// 이것이 위치 / 상대 선택자 인 경우 반환 된 집합의 멤버십을 확인합니다.
			// so $ ( "p : first"). is ( "p : last")는 두 개의 "p"가있는 문서에 대해 true를 반환하지 않습니다.
			typeof selector === "string"&& rneedsContext.test (selector)?
				jQuery (선택기) :
				선택기 || [],
			그릇된
		).길이;
	}
});


// jQuery 객체를 초기화한다.


// 루트 jQuery에 대한 중앙 참조 (문서)
var rootjQuery,

	// HTML 문자열을 검사하는 간단한 방법
	// location.hash (# 9521)를 통해 XSS를 피하기 위해 <tag> 위에 #id 우선 순위를 매기십시오.
	// 엄격한 HTML 인식 (# 11290 : <로 시작해야 함)
	// 단축키 simple #id의 경우 속도
	rquickExpr = / ^ (? : \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /

	init = jQuery.fn.init = function (선택자, 컨텍스트, 루트) {
		var match, elem;

		// HANDLE : $ ( ""), $ (null), $ (undefined), $ (false)
		if (! selector) {
			이것을 돌려 보내라.
		}

		// init () 메소드는 대체 rootjQuery를 허용합니다.
		// 그래서 migrate는 jQuery.sub (gh-2101)를 지원할 수있다.
		루트 = 루트 || rootjQuery;

		// HTML 문자열 처리
		if (typeof selector === "문자열") {
			if (selector [0] === "<"&&
				selector [selector.length - 1] === ">"&&
				selector.length> = 3) {

				// <>로 시작하고 끝나는 문자열이 HTML이고 정규식 검사를 건너 뜁니다.
				match = [null, selector, null];

			} else {
				match = rquickExpr.exec (selector);
			}

			// html과 일치하거나 #id에 지정된 컨텍스트가 없는지 확인하십시오.
			if (match && (match [1] || context)) {

				// HANDLE : $ (html) -> $ (배열)
				if (match [1]) {
					context = context instanceof jQuery? context [0] : 컨텍스트;

					// back-compat에서 스크립트를 실행하는 옵션이 true입니다.
					// 의도적으로 parseHTML이없는 경우 오류가 발생하도록합니다.
					jQuery.merge (this, jQuery.parseHTML (
						경기 [1],
						컨텍스트 && context.nodeType? context.ownerDocument || 컨텍스트 : 문서,
						참된
					));

					// HANDLE : $ (html, props)
					if (rsingleTag.test (match [1]) && jQuery.isPlainObject (context)) {
						for (문맥에서 일치) {

							// 가능한 경우 컨텍스트의 속성이 메서드로 호출됩니다.
							if (isFunction (this [match])) {
								this [match] (컨텍스트 [match]);

							// ... 그렇지 않으면 속성으로 설정합니다.
							} else {
								this.attr (match, context [match]);
							}
						}
					}

					이것을 돌려 보내라.

				// HANDLE : $ (# id)
				} else {
					elem = document.getElementById (match [2]);

					if (elem) {

						// jQuery 객체에 요소를 직접 삽입한다.
						this [0] = elem;
						this.length = 1;
					}
					이것을 돌려 보내라.
				}

			// HANDLE : $ (expr, $ (...))
			} else if (! context ?| context.jquery) {
				return (context || root) .find (selector);

			// HANDLE : $ (expr, context)
			// (이는 $ (context) .find (expr)와 동일하다.
			} else {
				return this.constructor (context) .find (selector);
			}

		// HANDLE : $ (DOMElement)
		} else if (selector.nodeType) {
			this [0] = selector;
			this.length = 1;
			이것을 돌려 보내라.

		// HANDLE : $ (함수)
		// 문서 준비를위한 바로 가기
		} else if (isFunction (selector)) {
			return root.ready! == undefined?
				root.ready (선택자) :

				// 준비가되어 있지 않으면 즉시 실행
				선택기 (jQuery);
		}

		return jQuery.makeArray (selector, this);
	};

// 나중에 인스턴스화 할 수 있도록 jQuery 프로토 타입을 init 함수에 제공합니다.
init.prototype = jQuery.fn;

// 중앙 참조 초기화
rootjQuery = jQuery (문서);


var rparentsprev = / ^ (?: parents | prev (? : Until | All)) /,

	// 고유 집합에서 시작할 때 고유 집합을 생성하도록 보장되는 메서드
	guaranteedUnique = {
		자녀 : 사실,
		내용 : 참,
		다음 : 참,
		이전 : true
	};

jQuery.fn.extend ({
	has : function (target) {
		var targets = jQuery (target, this),
			l = targets.length;

		return this.filter (function () {
			var i = 0;
			for (; i <l; i ++) {
				if (jQuery.contains (this, targets [i])) {
					참을 돌려라.
				}
			}
		});
	},

	closest : 함수 (선택자, 문맥) {
		var cur,
			i = 0,
			l = this.length,
			일치 = [],
			targets = typeof selector! == "문자열"&& jQuery (선택자);

		// _selection_ 컨텍스트가 없으므로 위치 선택기가 일치하지 않습니다.
		if (! rneedsContext.test (selectors)) {
			for (; i <l; i ++) {
				for (cur = this [i]; cur && cur! == context; cur = cur.parentNode) {

					// 항상 문서 조각을 건너 뜁니다.
					if (cur.nodeType <11 && (targets?
						targets.index (cur)> -1 :

						// 비 - 엘리먼트를 지글 지글로 전달하지 않는다.
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector (cur, selector))) {

						matched.push (cur);
						단절;
					}
				}
			}
		}

		반환 this.pushStack (matched.length> 1? jQuery.uniqueSort (matched) : matched);
	},

	// 집합 내의 요소 위치를 결정한다.
	색인 : function (elem) {

		// 인자가 없으므로 parent에 index를 반환합니다.
		if (! elem) {
			return (this [0] && this [0] .parentNode)? this.first (). prevAll (). length : -1;
		}

		// 셀렉터의 인덱스
		if (typeof elem === "string") {
			return indexOf.call (jQuery (elem), this [0]);
		}

		// 원하는 요소의 위치를 ​​찾습니다.
		return indexOf.call (this,

			// jQuery 객체를 받으면 첫 번째 요소가 사용됩니다.
			elem.jquery? elem [0] : elem
		);
	},

	추가 : function (selector, context) {
		돌려 주자 .pushStack (
			jQuery.uniqueSort (
				jQuery.merge (this.get (), jQuery (selector, context))
			)
		);
	},

	addBack : 함수 (selector) {
		return this.add (selector == null?
			this.prevObject : this.prevObject.filter (selector)
		);
	}
});

함수 형제 (cur, dir) {
	while ((cur = cur [dir]) && cur.nodeType! == 1) {}
	return cur;
}

jQuery.each ({
	parent : function (elem) {
		var parent = elem.parentNode;
		return parent && parent.nodeType! == 11? parent : null;
	},
	부모 : function (elem) {
		return dir (elem, "parentNode");
	},
	parentsUntil : function (elem, i, until) {
		return dir (elem, "parentNode", until);
	},
	다음 : function (elem) {
		형제를 반환합니다 (elem, "nextSibling");
	},
	이전 : function (elem) {
		형제를 반환합니다 (elem, "previousSibling");
	},
	nextAll : function (elem) {
		return dir (elem, "nextSibling");
	},
	prevAll : function (elem) {
		return dir (elem, "previousSibling");
	},
	nextUntil : function (elem, i, until) {
		return dir (elem, "nextSibling", until);
	},
	prevUntil : function (elem, i, until) {
		return dir (elem, "previousSibling", until);
	},
	형제 : function (elem) {
		형제를 반환하십시오 ((elem.parentNode || {}) .firstChild, elem);
	},
	children : function (elem) {
		형제 자매를 반환하십시오 (elem.firstChild);
	},
	내용 : function (elem) {
        if (nodeName (elem, "iframe")) {
            return elem.contentDocument;
        }

        // 지원 : IE 9-11 만, iOS 7 만, Android 브라우저 <= 4.3 만
        // 브라우저에서 템플릿 요소를 일반 요소로 처리합니다.
        // 지원하지 않습니다.
        if (nodeName (elem, "template")) {
            elem = elem.content || 엘름;
        }

        return jQuery.merge ([], elem.childNodes);
	}
}, function (name, fn) {
	jQuery.fn [name] = function (until, selector) {
		var matched = jQuery.map (this, fn, until);

		if (name.slice (-5)! == "Until") {
			selector = until;
		}

		if (selector && typeof selector === "string") {
			matched = jQuery.filter (selector, matched);
		}

		if (this.length> 1) {

			// 중복 제거
			if (! guaranteedUnique [name]) {
				jQuery.uniqueSort (일치);
			}

			// 부모 * 및 이전 파생 상품의 순서를 바꿉니다.
			if (rparentsprev.test (name)) {
				matched.reverse ();
			}
		}

		return this.pushStack (matched);
	};
});
var rnothtmlwhite = (/ [^ \ x20 \ t \ r \ n \ f] + / g);



// String 형식의 옵션을 Object 형식의 옵션으로 변환합니다.
함수 createOptions (옵션) {
	var object = {};
	jQuery.each (options.match (rnothtmlwhite) || [], 함수 (_, 플래그) {
		object [flag] = true;
	});
	개체를 반환;
}

/ *
 * 다음 매개 변수를 사용하여 콜백 목록을 만듭니다.
 *
 * options : 공간을 구분하는 옵션 목록으로 옵션을 변경하는 옵션입니다.
 * 콜백리스트가 동작하거나 더 전통적인 옵션 객체
 *
 * 기본적으로 콜백 목록은 이벤트 콜백 목록처럼 작동 할 수 있습니다.
 * "해고"여러 번.
 *
 * 가능한 옵션 :
 *
 * once : 콜백 목록이 한 번만 실행될 수 있도록합니다 (예 : Deferred와 같은).
 *
 * 메모리 : 이전 값을 추적하고 콜백을 추가로 호출합니다.
 * 목록이 최신 "암기 된"
 * 값 (예 : 지연된 값)
 *
 * unique : 콜백을 한 번만 추가 할 수 있습니다 (목록에 중복 없음).
 *
 * stopOnFalse : 콜백이 false를 반환 할 때 호출을 중단합니다.
 *
 * /
jQuery.Callbacks = function (options) {

	// 필요한 경우 String 형식에서 Object 형식으로 옵션 변환
	// (먼저 캐시에 체크 인합니다)
	options = typeof options === "문자열"?
		createOptions (옵션) :
		jQuery.extend ({}, options);

	var // 목록이 현재 실행 중인지 알기위한 플래그
		발사,

		// 잊지 못할 목록에 대한 마지막 화재 값
		기억,

		// 이미 실행 된 목록인지 여부를 나타내는 플래그
		해고,

		// 발사 방지 플래그
		잠긴,

		// 실제 콜백 목록
		목록 = [],

		// 반복 가능 목록에 대한 실행 데이터 대기열
		queue = [],

		// 현재 실행중인 콜백 인덱스 (필요에 따라 추가 / 제거하여 수정 됨)
		firingIndex = -1,

		// 콜백 호출
		화재 = 기능 () {

			// 단일 실행 실행
			잠긴 = 잠긴 || options.once;

			// 모든 보류중인 실행에 대한 콜백을 실행합니다.
			// firingIndex 재정의 및 런타임 변경 사항 준수
			해고 = 해고 = 사실;
			for (; queue.length; firingIndex = -1) {
				memory = queue.shift ();
				while (++ firingIndex <list.length) {

					// 콜백을 실행하고 조기 종료를 확인합니다.
					if (list [firingIndex] .apply (memory [0], memory [1]) === false &&
						options.stopOnFalse) {

						// 끝으로 건너 뛰고 데이터를 잊어 버리므로 .add가 다시 실행되지 않습니다.
						firingIndex = list.length;
						메모리 = 거짓;
					}
				}
			}

			// 작업이 끝나면 데이터를 잊어 버림
			if (! options.memory) {
				메모리 = 거짓;
			}

			사격 = 거짓;

			// 좋은 결과를 위해 해고가 끝나면 정리합니다.
			if (locked) {

				// 향후 추가 호출을위한 데이터가있는 경우 비어있는 목록 유지
				if (memory) {
					목록 = [];

				// 그렇지 않으면,이 객체는 소비됩니다.
				} else {
					list = "";
				}
			}
		},

		// 실제 콜백 객체
		자기 = {

			// 목록에 콜백 또는 콜백 콜렉션을 추가합니다.
			add : function () {
				if (list) {

					// 과거 실행으로 인한 메모리가 있으면 추가 한 후에 실행해야합니다.
					if (memory &&! firing) {
						firingIndex = list.length - 1;
						queue.push (메모리);
					}

					(함수 add (args) {
						jQuery.each (args, function (_, arg) {
							if (isFunction (arg)) {
								if (! options.unique ||! self.has (arg)) {
									list.push (arg);
								}
							} else if (arg && arg.length && toType (arg)! == "string") {

								// 재귀 적으로 검사
								add (arg);
							}
						});
					}) (인수);

					if (memory &&! firing) {
						불();
					}
				}
				이것을 돌려 보내라.
			},

			// 목록에서 콜백을 제거합니다.
			제거 : function () {
				jQuery.each (arguments, function (_, arg) {
					var 인덱스;
					while ((index = jQuery.inArray (arg, list, index))> -1) {
						list.splice (index, 1);

						// 실행 색인 처리
						if (index <= firingIndex) {
							firingIndex--;
						}
					}
				});
				이것을 돌려 보내라.
			},

			// 지정된 콜백이 목록에 있는지 확인합니다.
			// 인수가 지정되지 않은 경우 list에 콜백이 첨부되었는지 여부를 반환합니다.
			has : function (fn) {
				fn을 반환합니까?
					jQuery.inArray (fn, list)> -1 :
					list.length> 0;
			},

			// 목록에서 모든 콜백을 제거합니다.
			empty : function () {
				if (list) {
					목록 = [];
				}
				이것을 돌려 보내라.
			},

			// .fire 및 .add를 비활성화합니다.
			// 현재 실행 중이거나 보류중인 실행을 중단합니다.
			// 모든 콜백 및 값 지우기
			disable : function () {
				locked = queue = [];
				list = 메모리 = "";
				이것을 돌려 보내라.
			},
			비활성화 됨 : function () {
				리턴!리스트;
			},

			// .fire를 사용 중지합니다.
			// 우리가 메모리를 가지고 있지 않으면 (또한 효과가 없으므로) .add를 사용하지 않도록 설정하십시오.
			// 보류중인 실행을 중단합니다.
			lock : function () {
				locked = queue = [];
				if (! memory &&! firing) {
					list = 메모리 = "";
				}
				이것을 돌려 보내라.
			},
			잠김 : function () {
				돌아오다 !! 잠긴;
			},

			// 지정된 컨텍스트 및 인수를 사용하여 모든 콜백을 호출합니다.
			fireWith : function (context, args) {
				if (! locked) {
					args = args || [];
					args = [context, args.slice? args.slice () : args];
					queue.push (args);
					if (! 발사) {
						불();
					}
				}
				이것을 돌려 보내라.
			},

			// 주어진 인자로 모든 콜백을 호출한다.
			화재 : function () {
				self.fireWith (this, arguments);
				이것을 돌려 보내라.
			},

			// 콜백이 이미 적어도 한 번 호출되었는지 여부를 알고 싶습니다.
			해고 : function () {
				반환 !! 해고했다;
			}
		};

	자기를 돌려 보내라.
};


함수 식별 (v) {
	v를 되 돌린다.
}
함수 Thrower (예) {
	전을 던져라.
}

함수 adoptValue (값, 해결, 거부, noValue) {
	var 메소드;

	시도 {

		// 동기 동작을 우선적으로 약속하기 위해 약속 측면 확인
		if (value && isFunction ((method = value.promise))) {
			method.call (value) .done (resolve) .fail (reject);

		// 기타 사항
		} else if (value && isFunction ((method = value.then))) {
			method.call (value, resolve, reject);

		// 기타 비 주류
		} else {

			// Array # slice가 부울 값``noValue``를 정수로 만들어서`resolve` 인자를 제어합니다 :
			// * false : [value] .slice (0) => resolve (value)
			// * true : [값] .slice (1) => resolve ()
			resolve.apply (undefined, [value] .slice (noValue)));
		}

	// Promises / A +의 경우 예외를 거부로 변환합니다.
	// jQuery.when가 결과를 언랩하지 않기 때문에, 다음에 나오는 추가 체크를 건너 뛸 수 있습니다.
	// 조건부로 거부를 억제하려면 Deferred # then을 누릅니다.
	} catch (값) {

		// 지원 : Android 4.0 전용
		// .call없이 호출되는 엄격한 모드 함수 / .apply 전역 객체 컨텍스트를 얻습니다.
		reject.apply (undefined, [value]);
	}
}

jQuery.extend ({

	연기 됨 : function (func) {
		var 튜플 = [

				// 액션, 리스너 추가, 콜백,
				// .... 핸들러, 인수 인덱스, [최종 상태]
				[ "통지하다", "진행하다", jQuery.Callbacks ( "메모리"),
					jQuery.Callbacks ( "memory"), 2],
				[ "해결", "완료", jQuery.Callbacks ( "한번 메모리"),
					jQuery.Callbacks ( "once memory"), 0, "resolved"],
				[ "reject", "fail", jQuery.Callbacks ( "once once memory"),
					jQuery.Callbacks ( "once memory"), 1, "rejected"]
			],
			state = "pending",
			약속 = {
				state : function () {
					반환 상태;
				},
				항상 : function () {
					deferred.done (arguments) .fail (arguments);
					이것을 돌려 보내라.
				},
				"catch": function (fn) {
					return promise.then (null, fn);
				},

				// 이전 버전과 호환되는 파이프 유지
				파이프 : 함수 (/ * fnDone, fnFail, fnProgress * /) {
					var fns = arguments;

					return jQuery.Deferred (function (newDefer) {
						jQuery.each (튜플, 함수 (i, 튜플) {

							// 튜플 (진행, 완료, 실패)을 인수 (완료, 실패, 진행)에 매핑합니다.
							var fn = isFunction (fns [tuple [4]]) && fns [tuple [4]];

							// deferred.progress (function () {newDefer 또는 newDefer.notify에 바인딩})
							// deferred.done (function () {newDefer 또는 newDefer.resolve에 바인드})
							// deferred.fail (function () {newDefer 또는 newDefer.reject에 바인드})
							지연 [튜플 [1]] (함수 ​​() {
								var returned = fn && fn.apply (this, arguments);
								if (반환 된 && isFunction (반환 된 .promise)) {
									returned.promise ()
										.progress (newDefer.notify)
										.done (newDefer.resolve)
										.fail (newDefer.reject);
								} else {
									newDefer [tuple [0] + "With"]] (
										이,
										fn? [반환 된] 인수
									);
								}
							});
						});
						fns = null;
					}) .promise ();
				},
				다음 : function (onFulfilled, onRejected, onProgress) {
					var maxDepth = 0;
					함수 해결 (깊이, 지연, 핸들러, 특수) {
						return function () {
							var that = this,
								args = 인수,
								mightThrow = function () {
									var가 반환되었습니다.

									// 지원 : 약속 / A + 섹션 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// 더블 - 해상도 시도 무시
									if (depth <maxDepth) {
										반환;
									}

									반환 된 = handler.apply (그 args);

									// 지원 : 약속 / A + 섹션 2.3.1
									// https://promisesaplus.com/#point-48
									if (returned === deferred.promise ()) {
										새로운 TypeError를 던지십시오 ( "재기 가능한 자기 해결");
									}

									// 지원 : Promises / A + 섹션 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// 'then'을 한 번만 검색하십시오.
									then = returned &&

										// 지원 : 약속 / A + 섹션 2.3.4
										// https://promisesaplus.com/#point-64
										// 객체와 함수를 점검하여 객체 가능성을 확인하십시오.
										(반환 된 typeof === "object"||
											반환 된 typeof === "function") &&
										returned.then;

									// 반환 된 이름을 처리합니다.
									if (isFunction (then)) {

										// 특별한 프로세서 (알림) 만 해결을 기다린다.
										if (special) {
											then.call (
												반환 된,
												해결 (maxDepth, 지연, 신원, 특별),
												해결 (maxDepth, 지연, Thrower, 특수)
											);

										// 일반 프로세서 (해결)도 진행 상황에 연결합니다.
										} else {

											// ... 이전 해상도 값 무시
											maxDepth ++;

											then.call (
												반환 된,
												해결 (maxDepth, 지연, 신원, 특별),
												해결 (maxDepth, 지연, Thrower, 특수),
												해결 (maxDepth, 지연, 신원,
													deferred.notifyWith)
											);
										}

									// 다른 모든 반환 값을 처리합니다.
									} else {

										// 컨텍스트를 대체하는 핸들러 만 전달합니다.
										// 및 여러 값 (비표준 비헤이비어)
										if (handler! == Identity) {
											that = undefined;
											args = [반환];
										}

										// 값을 처리합니다.
										// 기본 프로세스가 해결됩니다.
										(special || deferred.resolveWith) (that, args);
									}
								},

								// 정상 프로세서 만 (해결) 예외 캐치 및 거부
								프로세스 = 특별?
									mightThrow :
									function () {
										시도 {
											mightThrow ();
										} catch (e) {

											if (jQuery.Deferred.exceptionHook) {
												jQuery.Deferred.exceptionHook (e,
													process.stackTrace);
											}

											// 지원 : 약속 / A + 섹션 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// post-resolution 예외를 무시합니다.
											if (depth + 1> = maxDepth) {

												// 컨텍스트를 대체하는 핸들러 만 전달합니다.
												// 및 여러 값 (비표준 비헤이비어)
												if (handler! = Thrower) {
													that = undefined;
													args = [e];
												}

												deferred.rejectWith (그, args);
											}
										}
									};

							// 지원 : 약속 / A + 섹션 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// 허위의 거절을 피하기 위해 즉시 약속을 재결정하십시오.
							// 후속 오류
							if (depth) {
								방법();
							} else {

								// 예외가 발생했을 때 스택을 기록하기위한 선택적인 훅을 호출한다.
								// 실행이 비동기가 될 때 손실되기 때문에
								if (jQuery.Deferred.getStackHook) {
									process.stackTrace = jQuery.Deferred.getStackHook ();
								}
								window.setTimeout (프로세스);
							}
						};
					}

					return jQuery.Deferred (function (newDefer) {

						// progress_handlers.add (...)
						튜플 [0] [3]. add (
							결의(
								0,
								newDefer,
								isFunction (onProgress)?
									onProgress :
									정체,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add (...)
						튜플 [1] [3]. add (
							결의(
								0,
								newDefer,
								isFunction (onFulfilled)?
									onFulfilled :
									정체
							)
						);

						// rejected_handlers.add (...)
						튜플 [2] [3]. add (
							결의(
								0,
								newDefer,
								isFunction (onRejected)?
									onRejected :
									던지는 사람
							)
						);
					}) .promise ();
				},

				//이 지연에 대한 약속 가져 오기
				// obj가 제공되면 promise aspect가 객체에 추가됩니다.
				약속 : function (obj) {
					return obj! = null? jQuery.extend (obj, promise) : promise;
				}
			},
			지연 = {};

		//리스트 - 특정 메소드를 추가한다.
		jQuery.each (튜플, 함수 (i, 튜플) {
			var list = tuple [2],
				stateString = 튜플 [5];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			약속 [tuple [1]] = list.add;

			// 핸들 상태
			if (stateString) {
				list.add (
					function () {

						// state = "resolved"(즉, 완료 됨)
						// state = "거부 됨"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					튜플 [3-i] [2] .disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					튜플 [3-i] [3] .disable,

					// progress_callbacks.lock
					튜플 [0] [2] .lock,

					// progress_handlers.lock
					튜플 [0] [3] .lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add (tuple [3] .fire);

			// deferred.notify = function () {deferred.notifyWith (...)}
			// deferred.resolve = function () {deferred.resolveWith (...)}
			// deferred.reject = function () {deferred.rejectWith (...)}
			지연 [tuple [0]] = 함수 () {
				deferred [tuple [0] + "With"] (this === deferred? undefined : this, arguments);
				이것을 돌려 보내라.
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred [tuple [0] + "With"] = list.fireWith;
		});

		// 지연된 약속으로 만듭니다.
		promise.promise (지연);

		// 주어진 func가 있으면 호출
		if (func) {
			func.call (지연, 지연);
		}

		// 모두 완료되었습니다!
		반환 지연;
	},

	// 지연된 도우미
	언제 : function (singleValue) {
		var

			// 완료되지 않은 하위의 개수
			remaining = arguments.length,

			// 처리되지 않은 인자의 개수
			i = 남은,

			// 하위의 이행 데이터
			resolveContexts = Array (i),
			resolveValues ​​= slice.call (arguments),

			// 마스터 Deferred
			master = jQuery.Deferred (),

			// 하위 콜백 팩토리
			updateFunc = function (i) {
				반환 함수 (값) {
					resolveContexts [i] = this;
					resolveValues ​​[i] = arguments.length> 1? slice.call (인수) : 값;
					if (! (--remaining)) {
						master.resolveWith (resolveContexts, resolveValues);
					}
				};
			};

		// 단일 인수와 빈 인수는 Promise.resolve처럼 채택됩니다.
		if (나머지 <= 1) {
			adoptValue (단일 값, master.done (updateFunc (i)) .resolve, master.reject,
				! 나머지);

			// 보조 어휘를 풀기 위해 .then ()을 사용한다 (cf. gh-3000 참조)
			if (master.state () === "pending"||
				isFunction (resolveValues ​​[i] && resolveValues ​​[i].))) {

				return master.then ();
			}
		}

		// 여러 인수는 Promise.all 배열 요소와 같이 집계됩니다.
		while (i--) {
			adoptValue (resolveValues ​​[i], updateFunc (i), master.reject);
		}

		return master.promise ();
	}
});


// 이들은 일반적으로 개발 과정에서 프로그래머가 실수 한 것을 나타내며,
// 기본적으로 삼키는 대신 최대한 빨리 경고합니다.
var rerrorNames = / ^ (Eval | Internal | Range | Reference | Syntax | Type | URI) 오류 $ /;

jQuery.Deferred.exceptionHook = function (오류, 스택) {

	// 지원 : IE 8 - 9 전용
	// 콘솔은 dev 도구가 열려있을 때 존재하며 언제든지 발생할 수 있습니다
	if (window.console && window.console.warn && error && rerrorNames.test (error.name)) {
		window.console.warn ( "jQuery.Deferred exception :"+ error.message, error.stack, stack);
	}
};




jQuery.readyException = function (오류) {
	window.setTimeout (function () {
		오류를 던집니다;
	});
};




// DOM 준비에 사용 된 지연
var readyList = jQuery.Deferred ();

jQuery.fn.ready = function (fn) {

	준비 목록
		. (fn)

		// 함수에서 jQuery.readyException을 감싸서 조회한다.
		// 콜백 대신 오류 처리시 발생 함
		// 등록.
		.catch (function (error) {
			jQuery.readyException (오류);
		});

	이것을 돌려 보내라.
};

jQuery.extend ({

	// DOM을 사용할 준비가 되었습니까? 일단 발생하면 true로 설정하십시오.
	isReady : false,

	// 전에 기다릴 아이템 수를 추적하는 카운터
	// ready 이벤트가 발생합니다. # 6781 참조
	준비 : 1,

	// DOM 준비가 완료되면 처리
	준비 : 기능 (대기) {

		// 보류중인 보류가있는 경우 중단하거나 이미 준비가 완료되었습니다.
		if (wait === true? - jQuery.readyWait : jQuery.isReady) {
			반환;
		}

		// DOM이 준비되었음을 기억하자.
		jQuery.isReady = true;

		// 정상적인 DOM 준비 이벤트가 발생하면 필요하다면 감소하고 대기한다.
		if (wait! == true && --jQuery.readyWait> 0) {
			반환;
		}

		// 바인딩 할 함수가 있으면 실행합니다.
		readyList.resolveWith (document, [jQuery]);
	}
});

jQuery.ready.then = readyList.then;

// 준비된 이벤트 핸들러 및 자체 정리 메소드
함수가 완료되었습니다 () {
	document.removeEventListener ( "DOMContentLoaded", completed);
	window.removeEventListener ( "load", completed);
	jQuery.ready ();
}

// $ (document) .ready ()가 호출 된 사례를 잡아라.
// 브라우저 이벤트가 이미 발생한 후.
// 지원 : IE <= 9 - 10 만
// 이전의 IE는 때때로 "대화 형"신호를 너무 빨리 보냅니다.
if (document.readyState === "complete"||
	(document.readyState! == "loading"&&! document.documentElement.doScroll)) {

	// 스크립트를 비동기 적으로 처리하여 스크립트가 준비를 지연시킬 수있는 기회를 허용합니다.
	window.setTimeout (jQuery.ready);

} else {

	// 편리한 이벤트 콜백을 사용한다.
	document.addEventListener ( "DOMContentLoaded", completed);

	// 항상 작동 할 window.onload로 폴백
	window.addEventListener ( "load", completed);
}




// 콜렉션의 값을 얻고 설정하는 다기능 메소드
// 함수의 경우 선택적으로 값 / s를 실행할 수 있습니다.
var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// 많은 값을 설정합니다.
	if (toType (key) === "object") {
		chainable = true;
		for (i in key) {
			액세스 (elems, fn, i, key [i], true, emptyGet, raw);
		}

	// 하나의 값을 설정합니다.
	} else if (value! == undefined) {
		chainable = true;

		if (! isFunction (value)) {
			원시 = 사실;
		}

		if (벌크) {

			// 전체 집합에 대해 대량 작업 실행
			if (raw) {
				fn.call (elems, value);
				fn = null;

			// ... 함수 값을 실행할 때를 제외하고
			} else {
				bulk = fn;
				fn = function (elem, key, value) {
					return bulk.call (jQuery (elem), value);
				};
			}
		}

		if (fn) {
			for (; i <len; i ++) {
				fn (
					elems [i], 열쇠, 날것?
					가치 :
					value.call (elems [i], i, fn (elems [i], key))
				);
			}
		}
	}

	if (chainable) {
		리턴 엘름;
	}

	// 얻는다.
	if (벌크) {
		return fn.call (elems);
	}

	len을 돌려 주시겠습니까? fn (elems [0], key) : emptyGet;
};


// camelizing을 위해 파선으로 일치
var rmsPrefix = / ^ - ms - /,
	rdashAlpha = / - ([az]) / g;

// replace ()에 콜백으로 camelCase에서 사용됩니다.
함수 fcamelCase (모두, 문자) {
	return letter.toUpperCase ();
}

// 점선을 camelCase로 변환; CSS 및 데이터 모듈에서 사용
// 지원 : IE <= 9 - 11, 가장자리 12 - 15
// 마이크로 소프트는 그들의 접두사 접두어를 깜빡 잊어 버렸습니다 (# 9572).
function camelCase (string) {
	return string.replace (rmsPrefix, "ms-") .replace (rdashAlpha, fcamelCase);
}
var acceptData = function (owner) {

	// 수락 전용 :
	// - 노드
	// - Node.ELEMENT_NODE
	// - Node.DOCUMENT_NODE
	// - Object
	// - 모두
	return owner.nodeType === 1 || owner.nodeType === 9 || ! (+ owner.nodeType);
};




함수 데이터 () {
	this.expando = jQuery.expando + Data.uid ++;
}

Data.uid = 1;

Data.prototype = {

	캐시 : 기능 (소유자) {

		// owner 객체에 이미 캐시가 있는지 확인합니다.
		var 값 = 소유자 [this.expando];

		// 그렇지 않으면 하나를 만듭니다.
		if (! value) {
			값 = {};

			// 현대의 브라우저에서는 비 요소 노드에 대한 데이터를 받아 들일 수 있지만,
			// 그러나 우리는 안됩니다. # 8335를보십시오.
			// 항상 빈 객체를 반환합니다.
			if (acceptData (owner)) {

				// stringify-ed 또는 looped 될 가능성이 적은 노드 인 경우
				// 일반 할당 사용
				if (owner.nodeType) {
					소유자 [this.expando] = 값;

				// 그렇지 않으면 열거 할 수없는 속성에서 보안 설정
				// 속성은 속성을 허용하려면 true 여야합니다.
				// 데이터가 제거되면 삭제됨
				} else {
					Object.defineProperty (owner, this.expando, {
						값 : 값,
						구성 가능 : true
					});
				}
			}
		}

		반환 값;
	},
	설정 : 기능 (소유자, 데이터, 값) {
		var prop,
			cache = this.cache (owner);

		// 핸들 : [owner, key, value] args
		// 항상 camelCase 키 사용 (gh-2257)
		if (typeof data === "string") {
			캐시 [camelCase (데이터)] = 값;

		// 핸들 : [owner, {properties}] args
		} else {

			// 캐시 객체에 속성을 하나씩 복사합니다.
			(데이터를 제공) {
				캐시 [camelCase (prop)] = 데이터 [prop];
			}
		}
		리턴 캐시;
	},
	get : function (owner, key) {
		return key === undefined?
			this.cache (소유자) :

			// 항상 camelCase 키 사용 (gh-2257)
			소유자 [this.expando] && 소유자 [this.expando] [camelCase (key)];
	},
	액세스 : 기능 (소유자, 키, 값) {

		// 다음 중 하나의 경우 :
		//
		// 1. 키가 지정되지 않았습니다.
		// 2. 문자열 키가 지정되었지만 값이 제공되지 않았습니다.
		//
		// "read"경로를 가져오고 get 메소드로 결정합니다.
		// 반환 할 값은 각각 다음 중 하나입니다.
		//
		// 1. 전체 캐시 객체
		// 2. 키에 저장된 데이터
		//
		if (key === undefined ||
				((키 && typeof 키 === "문자열") && value === undefined)) {

			돌려 주자 this.get (owner, key);
		}

		// 키가 문자열이 아니거나 키와 값이 아닌 경우
		//는 다음 중 하나를 사용하여 지정, 설정 또는 확장합니다 (기존 객체).
		//
		// 1. 속성의 객체
		// 2. 키와 값
		//
		this.set (owner, key, value);

		// "set"경로는 두 개의 가능한 엔트리 포인트를 가질 수 있기 때문에
		// 어떤 경로를 취했는지에 따라 예상되는 데이터를 반환합니다. [*]
		반환 값! == undefined? 값 : 키;
	},
	제거 : function (owner, key) {
		var i,
			cache = owner [this.expando];

		if (cache === undefined) {
			반환;
		}

		if (key! == undefined) {

			// 배열 또는 공백으로 구분 된 키 문자열 지원
			if (Array.isArray (key)) {

				// 키가 키 배열 인 경우 ...
				// 항상 camelCase 키를 설정하므로 제거하십시오.
				key = key.map (camelCase);
			} else {
				key = camelCase (key);

				// 공백이있는 키가 있으면 사용하십시오.
				// 그렇지 않으면, 비 공백을 매치 시켜서 배열을 만든다.
				키 = 캐시의 키?
					[열쇠] :
					(key.match (rnothtmlwhite) || []);
			}

			i = key.length;

			while (i--) {
				캐시 삭제 [key [i]];
			}
		}

		// 데이터가 더 이상 없다면 expando를 제거하십시오.
		if (key === undefined || jQuery.isEmptyObject (cache)) {

			// 지원 : Chrome <= 35 - 45
			// 속성을 삭제할 때 Webkit 및 Blink 성능이 저하됩니다.
			// DOM 노드에서 대신 undefined로 설정합니다.
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (버그가 제한됨)
			if (owner.nodeType) {
				소유자 [this.expando] = 정의되지 않음.
			} else {
				소유자 삭제 [this.expando];
			}
		}
	},
	hasData : function (owner) {
		var cache = owner [this.expando];
		리턴 캐시! == undefined &&! jQuery.isEmptyObject (cache);
	}
};
var dataPriv = 새 데이터 ();

var dataUser = new Data ();



// 구현 요약
//
// 1. 1.9.x 브랜치와의 API 표면 및 의미 적 호환성 강화
// 2. 저장 공간을 줄임으로써 모듈의 유지 보수성 향상
// 단일 메커니즘에 대한 경로.
// 3. 동일한 단일 메커니즘을 사용하여 "개인"및 "사용자"데이터를 지원합니다.
// 4. _Never_ 사용자 코드에 "개인"데이터 공개 (TODO : Drop _data, _removeData)
// 5. 사용자 객체에 대한 구현 세부 사항 노출 방지 (예 : expando 속성)
// 6. 2014 년 WeakMap으로 구현 업그레이드를위한 명확한 경로 제공

var rbrace = / ^ (? : \ {[\ w \ W] * \} | \ [[\ w \ W] * \]) $ /
	rmultiDash = / [AZ] / g;

함수 getData (데이터) {
	if (data === "true") {
		참을 돌려라.
	}

	if (data === "false") {
		false를 반환;
	}

	if (data === "null") {
		null를 돌려 준다.
	}

	// 문자열을 변경하지 않는 경우에만 숫자로 변환합니다.
	if (data === + data + "") {
		return + data;
	}

	if (rbrace.test (data)) {
		JSON.parse (data)를 반환합니다.
	}

	데이터를 반환;
}

함수 dataAttr (elem, key, data) {
	var name;

	// 내부적으로 아무 것도 발견되지 않은 경우,
	// HTML5 data- * 속성의 데이터
	if (data === undefined && elem.nodeType === 1) {
		name = "data-"+ key.replace (rmultiDash, "- $ &") .toLowerCase ();
		데이터 = elem.getAttribute (이름);

		if (typeof data === "string") {
			시도 {
				data = getData (data);
			} catch (e) {}

			// 데이터가 나중에 변경되지 않도록 데이터를 설정했는지 확인하십시오.
			dataUser.set (elem, key, data);
		} else {
			데이터 = 정의되지 않음;
		}
	}
	데이터를 반환;
}

jQuery.extend ({
	hasData : function (elem) {
		return dataUser.hasData (elem) || dataPriv.hasData (elem);
	},

	데이터 : 기능 (elem, 이름, 데이터) {
		return dataUser.access (elem, name, data);
	},

	removeData : function (elem, name) {
		dataUser.remove (elem, name);
	},

	// TODO : 이제 _data 및 _removeData에 대한 모든 호출이 대체되었습니다.
	// dataPriv 메소드에 대한 직접 호출을 사용하면 더 이상 지원되지 않을 수 있습니다.
	_data : function (elem, name, data) {
		return dataPriv.access (elem, name, data);
	},

	_removeData : function (elem, name) {
		dataPriv.remove (elem, name);
	}
});

jQuery.fn.extend ({
	데이터 : 기능 (키, 값) {
		var i, 이름, 데이터,
			elem = this [0],
			attrs = elem && elem.attributes;

		// 모든 값을 가져옵니다.
		if (key === undefined) {
			if (this.length) {
				data = dataUser.get (elem);

				if (elem.nodeType === 1 &&! dataPriv.get (elem, "hasDataAttrs")) {
					i = attrs.length;
					while (i--) {

						// 지원 : IE 11 만
						// attrs 요소는 null 일 수 있습니다 (# 14894).
						if (attrs [i]) {
							name = attrs [i] .name;
							if (name.indexOf ( "data-") === 0) {
								name = camelCase (name.slice (5));
								dataAttr (elem, name, data [name]);
							}
						}
					}
					dataPriv.set (elem, "hasDataAttrs", true);
				}
			}

			데이터를 반환;
		}

		// 여러 값을 설정합니다.
		if (typeof key === "object") {
			return this.each (function () {
				dataUser.set (this, key);
			});
		}

		반환 액세스 (this, function (value) {
			var 데이터;

			// 호출하는 jQuery 객체 (요소가 일치 함)가 비어 있지 않습니다.
			// (따라서이 [0]에 요소가 나타나고)
			// 'value` 매개 변수가 정의되지 않았습니다. 빈 jQuery 객체
			// elem = this [0]에 대해`undefined`가됩니다.
			// 데이터 캐시를 읽으려는 시도가 있으면 예외를 throw합니다.
			if (elem && value === undefined) {

				// 캐시에서 데이터를 가져 오려고 시도합니다.
				// 데이터에서 키가 항상 낙타가됩니다.
				data = dataUser.get (elem, key);
				if (data! == undefined) {
					데이터를 반환;
				}

				// 데이터를 "검색"하려고 시도합니다.
				// HTML5 사용자 정의 데이터 - * attrs
				data = dataAttr (elem, key);
				if (data! == undefined) {
					데이터를 반환;
				}

				// 정말 열심히 노력했지만 데이터가 존재하지 않습니다.
				반환;
			}

			// 데이터를 설정합니다 ...
			this.each (function () {

				// 항상 camelCased 키를 저장합니다.
				dataUser.set (this, key, value);
			});
		}, null, value, arguments.length> 1, null, true);
	},

	removeData : function (key) {
		return this.each (function () {
			dataUser.remove (this, key);
		});
	}
});


jQuery.extend ({
	큐 : function (elem, type, data) {
		var 대기열;

		if (elem) {
			type = (type || "fx") + "queue";
			queue = dataPriv.get (elem, type);

			// 그냥 조회 일 경우 빠르게 빠져 나가서 대기열에서 대기열에 놓기를 빠르게합니다.
			if (data) {
				if (! queue || Array.isArray (data)) {
					queue = dataPriv.access (elem, type, jQuery.makeArray (data));
				} else {
					queue.push (데이터);
				}
			}
			리턴 큐 || [];
		}
	},

	dequeue : function (elem, type) {
		type = type || "fx";

		var 큐 = jQuery.queue (elem, type),
			startLength = queue.length,
			fn = queue.shift (),
			후크 = jQuery._queueHooks (elem, type),
			다음 = 함수 () {
				jQuery.dequeue (elem, type);
			};

		// fx 큐가 큐에서 제거되면 항상 진행 센티널을 제거합니다.
		if (fn === "inprogress") {
			fn = queue.shift ();
			startLength--;
		}

		if (fn) {

			// fx 큐가 존재하지 않도록 진행 센티널을 추가합니다.
			// 자동으로 대기열에서 제외됩니다.
			if (type === "fx") {
				queue.unshift ( "inprogress");
			}

			// 마지막 큐 정지 함수를 지운다.
			delete hooks.stop;
			fn.call (elem, next, hooks);
		}

		if (! startLength && hooks) {
			hooks.empty.fire ();
		}
	},

	// public이 아닌 경우 - queueHooks 객체를 생성하거나 현재 객체를 반환합니다.
	_queueHooks : function (elem, type) {
		var key = type + "queueHooks";
		return dataPriv.get (elem, key) || dataPriv.access (elem, key, {
			empty : jQuery.Callbacks ( "once memories") .add (function () {
				dataPriv.remove (elem, [type + "queue", key]);
			})
		});
	}
});

jQuery.fn.extend ({
	대기열 : 기능 (유형, 데이터) {
		var setter = 2;

		if (typeof type! == "string") {
			데이터 = 유형;
			type = "fx";
			세터--;
		}

		if (arguments.length <setter) {
			return jQuery.queue (this [0], type);
		}

		데이터를 반환 === undefined?
			이 :
			this.each (function () {
				var queue = jQuery.queue (this, type, data);

				//이 대기열에 대한 후크를 보장합니다.
				jQuery._queueHooks (this, type);

				if (type === "fx"&& queue [0]! == "inprogress") {
					jQuery.dequeue (this, type);
				}
			});
	},
	dequeue : 함수 (유형) {
		return this.each (function () {
			jQuery.dequeue (this, type);
		});
	},
	clearQueue : function (type) {
		이것을 반환하십시오. 큐 (type || "fx", []);
	},

	// 특정 유형의 대기열이 해결되면 약속을 얻습니다.
	// 비어 있습니다 (fx는 기본적으로 유형 임).
	약속 : function (type, obj) {
		var tmp,
			카운트 = 1,
			defer = jQuery.Deferred (),
			요소 = this,
			i = this.length,
			해결 = function () {
				if (! (--count)) {
					defer.resolveWith (요소, [요소]);
				}
			};

		if (typeof type! == "string") {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while (i--) {
			tmp = dataPriv.get (elements [i], type + "queueHooks");
			if (tmp && tmp.empty) {
				카운트 ++;
				tmp.empty.add (resolve);
			}
		}
		결의();
		return defer.promise (obj);
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?¥d+|)/) .source;

var rcssNum = new RegExp ( "^ (? : ([+ -]) = |) ("+ pnum + ") ([az %] *) $", "i");


var cssExpand = [ "Top", "Right", "Bottom", "Left"];

var isHiddenWithinTree = function (elem, el) {

		// isHiddenWithinTree가 jQuery # 필터 함수에서 호출 될 수 있습니다.
		//이 경우 요소는 두 번째 인수가됩니다.
		elem = el || 엘름;

		// 인라인 스타일이 모두 우선합니다.
		return elem.style.display === "none"||
			elem.style.display === ""&&

			// 그렇지 않으면 계산 된 스타일을 확인합니다.
			// 지원 : Firefox <= 43 - 45
			// 연결이 끊긴 요소는 display : none을 계산할 수 있으므로 먼저 elem이
			// 문서에서.
			jQuery.contains (elem.ownerDocument, elem) &&

			jQuery.css (elem, "display") === "none";
	};

var swap = function (elem, 옵션, 콜백, args) {
	var ret, name,
		old = {};

	// 이전 값을 기억하고 새 값을 삽입합니다.
	for (옵션 이름) {
		이전 [이름] = elem.style [이름];
		elem.style [name] = 옵션 [이름];
	}

	ret = callback.apply (elem, args || []);

	// 이전 값 되돌리기
	for (옵션 이름) {
		elem.style [이름] = 이전 [이름];
	}

	return ret;
};




function adjustCSS (elem, prop, valueParts, tween) {
	var 조정, 규모,
		maxIterations = 20,
		currentValue = 트윈?
			function () {
				return tween.cur ();
			} :
			function () {
				return jQuery.css (elem, prop, "");
			},
		initial = currentValue (),
		unit = valueParts && valueParts [3] || (jQuery.cssNumber [prop]? "": "px"),

		// 잠재적 인 유닛 불일치에는 시작 값 계산이 필요합니다.
		initialInUnit = (jQuery.cssNumber [prop] || 단위! == "px"&& + 초기) &&
			rcssNum.exec (jQuery.css (elem, prop));

	if (initialInUnit && initialInUnit [3]! == unit) {

		// 지원 : Firefox <= 54
		// CSS 상한선의 간섭을 막기 위해 반복 목표 값을 반으로 줄입니다 (gh-2144).
		초기 = 초기 / 2;

		// jQuery.css에 의해보고 된 신뢰 단위
		단위 = 단위 || initialInUnit [3];

		// 0이 아닌 시작점에서 반복적으로 근사합니다.
		initialInUnit = + 초기 || 1;

		while (maxIterations--) {

			// 가장 좋은 추측을 평가하고 업데이트합니다 (추측치를 두 배로 늘림).
			// scale이 1과 같거나 교차 할 경우 마침을 클릭합니다 (이전 * 새로운 제품이 양수가 아닙니다).
			jQuery.style (elem, prop, initialInUnit + unit);
			if ((1-scale) * (1 - (scale = currentValue () / initial || 0.5)) <= 0) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style (elem, prop, initialInUnit + unit);

		// 나중에 tween 속성을 업데이트해야합니다.
		valueParts = valueParts || [];
	}

	if (valueParts) {
		initialInUnit = + initialInUnit || + 초기 || 0;

		// 지정된 경우 상대 오프셋 (+ = / - =)을 적용합니다.
		adjusted = valueParts [1]?
			initialInUnit + (valueParts [1] + 1) * valueParts [2] :
			+ valueParts [2];
		if (tween) {
			tween.unit = 단위;
			tween.start = initialInUnit;
			tween.end = 조정 됨;
		}
	}
	반환 조정;
}


var defaultDisplayMap = {};

함수 getDefaultDisplay (elem) {
	var 온도,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap [nodeName];

	if (display) {
		리턴 디스플레이;
	}

	임시 = doc.body.appendChild (doc.createElement (nodeName));
	display = jQuery.css (temp, "display");

	temp.parentNode.removeChild (temp);

	if (display === "none") {
		display = "블록";
	}
	defaultDisplayMap [nodeName] = 표시;

	리턴 디스플레이;
}

함수 showHide (elements, show) {
	var 디스플레이, elem,
		값 = [],
		인덱스 = 0,
		length = elements.length;

	// 변경해야하는 요소의 새 표시 값 결정
	for (; index <length; index ++) {
		elem = 요소 [색인];
		if (! elem.style) {
			잇다;
		}

		display = elem.style.display;
		if (show) {

			// 캐스케이드가 숨겨진 요소를 강제로 표시하므로 즉시 (및 느린)
			// 비어 있지 않은 표시 값이없는 한이 첫 번째 루프에서 check가 필요합니다 (어느 것이 든
			// 인라인 또는 약 복원 예정)
			if (display === "none") {
				values ​​[index] = dataPriv.get (elem, "display") || 없는;
				if (! values ​​[index]) {
					elem.style.display = "";
				}
			}
			if (elem.style.display === ""&& isHiddenWithinTree (elem)) {
				값 [인덱스] = getDefaultDisplay (elem);
			}
		} else {
			if (display! == "none") {
				값 [인덱스] = "없음";

				// 우리가 겹쳐 쓰는 것을 기억하십시오.
				dataPriv.set (elem, "display", display);
			}
		}
	}

	// 지속적인 리플 로우를 피하기 위해 두 번째 루프에서 요소 표시를 설정합니다.
	for (index = 0; index <length; index ++) {
		if (values ​​[index]! = null) {
			요소들 [index] .style.display = values ​​[index];
		}
	}

	요소를 반환;
}

jQuery.fn.extend ({
	show : function () {
		return showHide (this, true);
	},
	숨기기 : function () {
		return showHide (this);
	},
	토글 : function (state) {
		if (typeof state === "boolean") {
			반환 상태? this.show () : this.hide ();
		}

		return this.each (function () {
			if (isHiddenWithinTree (this)) {
				jQuery (this) .show ();
			} else {
				jQuery (this) .hide ();
			}
		});
	}
});
var rcheckableType = (/ ^ (? : checkbox | radio) $ / i);

var rtagName = (/ <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i);

var rscriptType = (/ ^^ $ | ^ module $ | \ / (?: java | ecma) 스크립트 / i);



// XHTML을 지원하기 위해이 태그를 닫아야합니다 (# 13200).
var wrapMap = {

	// 지원 : IE <= 9 만
	옵션 : [1, "<select multiple = 'multiple'>", "</ select>"],

	// XHTML 파서는 요소를 마술처럼 삽입하지 않습니다.
	// 태그 수프 파서가하는 것과 같은 방식입니다. 그래서 우리는 단축 할 수 없다.
	<tbody> 또는 다른 필수 요소를 생략하여이 작업을 수행합니다.
	thead : [1, "<table>", "</ table>"],
	col : [2, "<table> <colgroup>", "</ colgroup> </ table>"],
	tr : [2, "<table> <tbody>", "</ tbody> </ table>"],
	td : [3, "<table> <tbody> <tr>", "</ tr> </ tbody> </ table>"]

	_default : [0, "", ""]
};

// 지원 : IE <= 9 만
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


함수 getAll (context, tag) {

	// 지원 : IE <= 9 - 11 전용
	// typeof를 사용하여 호스트 객체에 인자가없는 메소드 호출을 방지합니다 (# 15151).
	var ret;

	if (typeof context.getElementsByTagName! == "undefined") {
		ret = context.getElementsByTagName (tag || "*");

	} else if (typeof context.querySelectorAll! == "undefined") {
		ret = context.querySelectorAll (tag || "*");

	} else {
		ret = [];
	}

	if (tag === undefined || tag && nodeName (context, tag)) {
		return jQuery.merge ([컨텍스트], ret);
	}

	return ret;
}


// 이미 평가 된 것으로 스크립트를 표시합니다.
함수 setGlobalEval (elems, refElements) {
	var i = 0,
		l = elems.length;

	for (; i <l; i ++) {
		dataPriv.set (
			elems [i],
			"globalEval",
			! refElements || dataPriv.get (refElements [i], "globalEval")
		);
	}
}


var rhtml = / <| & #? \ w +; /;

함수 buildFragment (elems, 문맥, 스크립트, 선택, 무시) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment (),
		nodes = [],
		i = 0,
		l = elems.length;

	for (; i <l; i ++) {
		elem = elems [i];

		if (elem || elem === 0) {

			// 노드를 직접 추가
			if (toType (elem) === "object") {

				// 지원 : Android <= 4.0 전용, PhantomJS 1 전용
				// push.apply (_, arraylike) 고대 Webkit을 던졌습니다.
				jQuery.merge (nodes, elem.nodeType? [elem] : elem);

			// non-html을 텍스트 노드로 변환
			} else if (! rhtml.test (elem)) {
				nodes.push (context.createTextNode (elem));

			// html을 DOM 노드로 변환
			} else {
				tmp = tmp || fragment.appendChild (context.createElement ( "div"));

				// 표준 표현을 직렬화 해제합니다.
				tag = (rtagName.exec (elem) || [ "", ""]) [1] .toLowerCase ();
				wrap = wrapMap [태그] || wrapMap._default;
				tmp.innerHTML = wrap [1] + jQuery.htmlPrefilter (elem) + wrap [2];

				// 래퍼를 통해 올바른 컨텐트로 내려갑니다.
				j = 랩 [0];
				while (j--) {
					tmp = tmp.lastChild;
				}

				// 지원 : Android <= 4.0 전용, PhantomJS 1 전용
				// push.apply (_, arraylike) 고대 Webkit을 던졌습니다.
				jQuery.merge (노드, tmp.childNodes);

				// 최상위 컨테이너를 기억한다.
				tmp = fragment.firstChild;

				// 생성 된 노드가 고아가되었는지 확인합니다 (# 12392)
				tmp.textContent = "";
			}
		}
	}

	// 조각에서 래퍼를 제거합니다.
	fragment.textContent = "";

	i = 0;
	while ((elem = nodes [i ++])) {

		// 컨텍스트 컬렉션에 이미있는 요소를 건너 뜁니다 (trac-4087).
		if (selection && jQuery.inArray (elem, selection)> -1) {
			if (무시) ​​{
				ignored.push (elem);
			}
			잇다;
		}

		contains = jQuery.contains (elem.ownerDocument, elem);

		// 조각에 추가
		tmp = getAll (fragment.appendChild (elem), "script");

		// 스크립트 평가 기록 보존
		if (contains) {
			setGlobalEval (tmp);
		}

		// 실행 파일 캡처
		if (scripts) {
			j = 0;
			while ((elem = tmp [j ++])) {
				if (rscriptType.test (elem.type || "")) {
					scripts.push (elem);
				}
			}
		}
	}

	파편을 돌려 보내라.
}


(function () {
	var fragment = document.createDocumentFragment (),
		div = fragment.appendChild (document.createElement ( "div")),
		입력 = document.createElement ( "입력");

	// 지원 : Android 4.0 - 4.3 전용
	// 이름이 설정되면 상태 손실 확인 (# 11217)
	// 지원 : Windows Web Apps (WWA)
	//`name`과`type`은 WWA에 .setAttribute를 사용해야합니다 (# 14901).
	input.setAttribute ( "type", "radio");
	input.setAttribute ( "checked", "checked");
	input.setAttribute ( "name", "t");

	div.appendChild (입력);

	// 지원 : 안드로이드 <= 4.1 전용
	// 오래된 WebKit은 조각으로 체크 된 상태를 올바르게 복제하지 않습니다.
	support.checkClone = div.cloneNode (true) .cloneNode (true) .lastChild.checked;

	// 지원 : IE <= 11 만
	// textarea (및 checkbox) defaultValue가 올바르게 복제되었는지 확인합니다.
	div.innerHTML = "<textarea> x </ textarea>";
	support.noCloneChecked = !! div.cloneNode (true) .lastChild.defaultValue;
}) ();
var documentElement = document.documentElement;



var
	rkeyEvent = / ^ key /,
	rmouseEvent = / ^ (? : mouse | pointer | contextmenu | drag | drop) | /를 클릭하십시오.
	rtypenamespace = /^([^.]*)(?:\\(.+)|)/;

함수 returnTrue () {
	참을 돌려라.
}

함수 returnFalse () {
	false를 반환;
}

// 지원 : IE <= 9 만
// 자세한 내용은 # 13393을 참조하십시오.
function safeActiveElement () {
	시도 {
		document.activeElement를 반환합니다.
	} catch (err) {}
}

function on (elem, 유형, 선택기, 데이터, fn, 하나) {
	var origFn, type;

	// 유형은 유형 / 핸들러의 맵이 될 수 있습니다.
	if (typeof types === "object") {

		// (types-Object, selector, data)
		if (typeof selector! == "string") {

			// (types-Object, data)
			데이터 = 데이터 || 선택자;
			selector = undefined;
		}
		for (유형 입력) {
			on (elem, type, selector, data, types [type], one);
		}
		return elem;
	}

	if (data == null && fn == null) {

		// (유형, fn)
		fn = 선택자;
		데이터 = 선택기 = 정의되지 않은;
	} else if (fn == null) {
		if (typeof selector === "문자열") {

			// (유형, 선택자, fn)
			fn = 데이터;
			데이터 = 정의되지 않음;
		} else {

			// (유형, 데이터, fn)
			fn = 데이터;
			데이터 = 선택자;
			selector = undefined;
		}
	}
	if (fn === false) {
		fn = returnFalse;
	} else if (! fn) {
		return elem;
	}

	if (one === 1) {
		origFn = fn;
		fn = 함수 (이벤트) {

			// 이벤트에 정보가 포함되어 있으므로 빈 세트를 사용할 수 있습니다.
			jQuery (). off (이벤트);
			origFn.apply (this, arguments)를 반환하십시오.
		};

		// 발신자가 origFn을 사용하여 제거 할 수 있도록 동일한 GUID 사용
		fn.guid = origFn.guid || (origFn.guid = jQuery.guid ++);
	}
	return elem.each (function () {
		jQuery.event.add (this, types, fn, data, selector);
	});
}

/ *
 이벤트 관리를위한 * 도우미 기능 - 공용 인터페이스의 일부가 아닙니다.
 * 많은 아이디어를 위해 Dean Edwards의 addEvent 라이브러리에 대한 소품.
 * /
jQuery.event = {

	전역 : {},

	추가 : function (elem, types, handler, data, selector) {

		var handleObjIn, eventHandle, tmp,
			이벤트, t, handleObj,
			특수, 핸들러, 유형, 네임 스페이스, origType,
			elemData = dataPriv.get (elem);

		// noData 또는 텍스트 / 주석 노드에 이벤트를 첨부하지 않습니다 (단, 일반 객체 허용).
		if (! elemData) {
			반환;
		}

		// 호출자는 핸들러 대신 사용자 정의 데이터의 객체를 전달할 수 있습니다.
		if ( handler.handler) {
			handleObjIn = 핸들러;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// 잘못된 셀렉터가 연결시 예외를 throw하는지 확인합니다.
		elem이 비 요소 노드 (예 : document) 인 경우 documentElement에 대해 평가합니다.
		if (selector) {
			jQuery.find.matchesSelector (documentElement, selector);
		}

		// 핸들러가 고유 한 ID를 가지고 있는지 확인하여 나중에 찾거나 제거하는 데 사용합니다.
		if (! handler.guid) {
			handler.guid = jQuery.guid ++;
		}

		// 요소의 이벤트 구조와 주 처리기를 초기화합니다 (첫 번째 경우).
		if (! (events = elemData.events)) {
			events = elemData.events = {};
		}
		if (! (eventHandle = elemData.handle)) {
			eventHandle = elemData.handle = function (e) {

				// jQuery.event.trigger ()의 두 번째 이벤트를 버립니다.
				// 페이지가 언로드 된 후 이벤트가 호출 될 때
				typeof jQuery를 반환하십시오! == "undefined"&& jQuery.event.triggered! == e.type?
					jQuery.event.dispatch.apply (elem, arguments) : undefined;
			};
		}

		// 여러 이벤트를 공백으로 구분하여 처리합니다.
		types = (types || "") .match (rnothtmlwhite) || [ ""];
		t = types.length;
		while (t--) {
			tmp = rtypenamespace.exec (유형 [t]) || [];
			type = origType = tmp [1];
			namespaces = (tmp [2] || "") .split ( ".") .sort ();

			// 타입은 *이어야하며, 네임 스페이스 전용 핸들러는 붙이지 않아야합니다.
			if (! type) {
				잇다;
			}

			// 이벤트가 유형을 변경하면 변경된 유형에 대한 특수 이벤트 핸들러를 사용합니다.
			special = jQuery.event.special [type] || {};

			// selector가 정의 된 경우 특수 이벤트 api 유형을 결정하고 그렇지 않으면 지정된 유형을 결정합니다.
			type = (selector? special.delegateType : special.bindType) || 유형;

			// 새로 재설정 된 유형을 기반으로 특수 업데이트
			special = jQuery.event.special [type] || {};

			// handleObj가 모든 이벤트 핸들러에 전달됩니다.
			handleObj = jQuery.extend ({
				유형 : 유형,
				origType : origType,
				데이터 : 데이터,
				handler : 핸들러,
				guid : handler.guid,
				선택자 : 선택자,
				needsContext : selector && jQuery.expr.match.needsContext.test (selector),
				namespace : namespaces.join ( ".")
			}, handleObjIn);

			// 우리가 처음이라면 이벤트 핸들러 큐를 초기화한다.
			if (! (핸들러 = 이벤트 [유형])) {
				처리기 = 이벤트 [유형] = [];
				handlers.delegateCount = 0;

				// 특수 이벤트 핸들러가 false를 반환하는 경우에만 addEventListener를 사용합니다.
				if (! special.setup ||
					special.setup.call (elem, data, namespaces, eventHandle) === false) {

					if (elem.addEventListener) {
						elem.addEventListener (type, eventHandle);
					}
				}
			}

			if (special.add) {
				special.add.call (elem, handleObj);

				if (! handleObj.handler.guid) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// 요소의 핸들러 목록에 대리자를 추가합니다.
			if (selector) {
				handlers.splice (handlers.delegateCount ++, 0, handleObj);
			} else {
				handlelers.push (handleObj);
			}

			// 이벤트 최적화를 위해 어떤 이벤트가 사용되었는지 추적합니다.
			jQuery.event.global [type] = true;
		}

	},

	// 요소에서 이벤트 또는 이벤트 집합을 분리합니다.
	제거 : function (elem, types, handler, selector, mappedTypes) {

		var j, origCount, tmp,
			이벤트, t, handleObj,
			특수, 핸들러, 유형, 네임 스페이스, origType,
			elemData = dataPriv.hasData (elem) && dataPriv.get (elem);

		if (! elemData ||! (events = elemData.events)) {
			반환;
		}

		// 각 type.namespace 유형에 대해 한 번씩; 형식 생략 가능
		types = (types || "") .match (rnothtmlwhite) || [ ""];
		t = types.length;
		while (t--) {
			tmp = rtypenamespace.exec (유형 [t]) || [];
			type = origType = tmp [1];
			namespaces = (tmp [2] || "") .split ( ".") .sort ();

			// 요소에 대한이 네임 스페이스의 모든 이벤트를 바인딩 해제합니다.
			if (! type) {
				for (이벤트 입력) {
					jQuery.event.remove (elem, type + types [t], 핸들러, selector, true);
				}
				잇다;
			}

			special = jQuery.event.special [type] || {};
			type = (selector? special.delegateType : special.bindType) || 유형;
			핸들러 = 이벤트 [타입] || [];
			tmp = tmp [2] &&
				새 RegExp ( "(^ | \\.)"+ namespaces.join ( "\\. (? :. * \\. |)") + "(\\. | $)");

			// 일치하는 이벤트 제거
			origCount = j = handlers.length;
			while (j--) {
				handleObj = 핸들러 [j];

				if ((mappedTypes || origType === handleObj.origType) &&
					(! handler || handler.guid === handleObj.guid) &&
					(! tmp || tmp.test (handleObj.namespace)) &&
					(! selector || selector === handleObj.selector ||
						selector === "**"&& handleObj.selector)) {
					handlers.splice (j, 1);

					if (handleObj.selector) {
						handlers.delegateCount--;
					}
					if (special.remove) {
						special.remove.call (elem, handleObj);
					}
				}
			}

			// 뭔가를 제거하고 더 이상 처리기가없는 경우 일반 이벤트 핸들러를 제거합니다.
			// (특별한 이벤트 처리기를 제거하는 동안 무한 재귀가 발생할 가능성이 없음)
			if (origCount &&! handlers.length) {
				if (! special.teardown ||
					special.teardown.call (elem, 네임 스페이스, elemData.handle) === false) {

					jQuery.removeEvent (elem, type, elemData.handle);
				}

				이벤트 삭제 [유형];
			}
		}

		// 더 이상 사용하지 않으면 데이터와 확장을 제거합니다.
		if (jQuery.isEmptyObject (events)) {
			dataPriv.remove (elem, "이벤트 처리");
		}
	},

	dispatch : function (nativeEvent) {

		// 네이티브 이벤트 객체로부터 쓰기 가능한 jQuery.Event를 만든다.
		var event = jQuery.event.fix (nativeEvent);

		var i, j, ret, 일치, handleObj, handlerQueue,
			args = new Array (arguments.length),
			처리기 = (dataPriv.get (this, "events") || {}) [event.type] || [],
			special = jQuery.event.special [event.type] || {};

		// (읽기 전용) 기본 이벤트가 아닌 수정 된 jQuery.Event를 사용하십시오.
		args [0] = event;

		for (i = 1; i <arguments.length; i ++) {
			args [i] = 인수 [i];
		}

		event.delegateTarget = this;

		// 매핑 된 유형에 대해 preDispatch 훅을 호출하고 원하는 경우 보석금을 둡니다.
		if (special.preDispatch && special.preDispatch.call (this, event) === false) {
			반환;
		}

		// 핸들러를 결정한다.
		handlerQueue = jQuery.event.handlers.call (this, event, handlers);

		// 먼저 델리게이트를 실행합니다. 그들은 우리 밑에서 번식을 멈추고 싶어할지 모른다.
		i = 0;
		while (일치하는 = handlerQueue [i ++]) &&! event.isPropagationStopped ()) {
			event.currentTarget = matched.elem;

			j = 0;
			while ((handleObj = matched.handlers [j ++]) &&
				! event.isImmediatePropagationStopped ()) {

				// 트리거 된 이벤트는 1) 네임 스페이스가 없거나 2) 네임 스페이스가 있어야합니다.
				// 바운드 이벤트의 하위 집합 또는 하위 집합 (둘 다 네임 스페이스가 없음).
				if (! event.rnamespace || event.rnamespace.test (handleObj.namespace)) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ((jQuery.event.special [handleObj.origType] || {}) .handle ||
						handleObj.handler) .apply (matched.elem, args);

					if (ret! == undefined) {
						if ((event.result = ret) === false) {
							event.preventDefault ();
							event.stopPropagation ();
						}
					}
				}
			}
		}

		// 매핑 된 유형에 대해 postDispatch 훅을 호출합니다.
		if (special.postDispatch) {
			special.postDispatch.call (this, event);
		}

		return event.result;
	},

	핸들러 : function (이벤트, 핸들러) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// 델리게이트 핸들러 찾기
		if (delegateCount &&

			// 지원 : IE <= 9
			// 블랙홀 SVG <use> 인스턴스 트리 (trac-13180)
			cur.nodeType &&

			// 지원 : Firefox <= 42
			// 기본이 아닌 포인터 버튼을 나타내는 spec-violating 클릭을 억제합니다 (trac-3861).
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// 지원 : IE 11 만
			// ... 그러나 "button"-1 (gh-2343)을 가질 수있는 라디오 입력의 화살표 키 "클릭"이 아닙니다.
			! (event.type === "click"&& event.button> = 1)) {

			for (; cur! == this; cur = cur.parentNode || this) {

				// 비 요소 검사 안 함 (# 13208)
				// 사용 중지 된 요소에 대한 클릭을 처리하지 않습니다 (# 6911, # 8165, # 11382, # 11764).
				if (cur.nodeType === 1 &&! (event.type === "click"&& cur.disabled === true)) {
					matchedHandlers = [];
					matchedSelectors = {};
					for (i = 0; i <delegateCount; i ++) {
						handleObj = 핸들러 [i];

						// Object.prototype 속성과 충돌하지 않습니다 (# 13203).
						sel = handleObj.selector + "";

						if (matchedSelectors [sel] === undefined) {
							matchedSelectors [sel] = handleObj.needsContext?
								jQuery (sel, this) .index (cur)> -1 :
								jQuery.find (sel, this, null, [cur]) .length;
						}
						if (matchedSelectors [sel]) {
							matchedHandlers.push (handleObj);
						}
					}
					if (matchedHandlers.length) {
						handlerQueue.push ({elem : cur, 핸들러 : matchedHandlers});
					}
				}
			}
		}

		// 나머지 (직접 바인딩 된) 핸들러를 추가합니다.
		cur = this;
		if (delegateCount <handlers.length) {
			handlerQueue.push ({elem : cur, handlers : handlers.slice (delegateCount)});
		}

		return handlerQueue;
	},

	addProp : function (name, hook) {
		Object.defineProperty (jQuery.Event.prototype, name, {
			열거 형 : 참,
			구성 가능 : true,

			get : isFunction (hook)?
				function () {
					if (this.originalEvent) {
							리턴 훅 (this.originalEvent);
					}
				} :
				function () {
					if (this.originalEvent) {
							이것을 반환하십시오. 원본 이벤트 [이름];
					}
				},

			설정 : 함수 (값) {
				Object.defineProperty (this, name, {
					열거 형 : 참,
					구성 가능 : true,
					쓰기 가능 : true,
					값 : 값
				});
			}
		});
	},

	수정 : function (originalEvent) {
		originalEvent [jQuery.expando]를 반환 하시겠습니까?
			originalEvent :
			새로운 jQuery.Event (originalEvent);
	},

	특별 : {
		로드 : {

			// 트리거 된 image.load 이벤트가 window.load로 버블 링되는 것을 방지합니다.
			noBubble : true
		},
		초점 : {

			// 가능한 경우 네이티브 이벤트를 실행하므로 흐림 / 포커스 시퀀스가 ​​정확합니다.
			트리거 : function () {
				if (this! == safeActiveElement () && this.focus) {
					this.focus ();
					false를 반환;
				}
			},
			delegateType : "focusin"
		},
		흐림 : {
			트리거 : function () {
				if (this === safeActiveElement () && this.blur) {
					this.blur ();
					false를 반환;
				}
			},
			delegateType : "focusout"
		},
		클릭 : {

			// 체크 상자의 경우 네이티브 이벤트를 실행하면 체크 된 상태가됩니다.
			트리거 : function () {
				if (this.type === "checkbox"&& this.click && nodeName (this, "input")) {
					this.click ();
					false를 반환;
				}
			},

			// 브라우저 간 일관성 유지를 위해 링크에서 기본 .click ()을 실행하지 마십시오.
			_default : function (이벤트) {
				return nodeName (event.target, "a");
			}
		},

		beforeunload : {
			postDispatch : function (이벤트) {

				// 지원 : Firefox 20 이상
				// returnValue 필드가 설정되어 있지 않으면 Firefox가 경고하지 않습니다.
				if (event.result! == undefined && event.originalEvent) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function (elem, type, handle) {

	//이 "if"가 일반 객체에 필요합니다.
	if (elem.removeEventListener) {
		elem.removeEventListener (type, handle);
	}
};

jQuery.Event = function (src, props) {

	// 'new'키워드없이 인스턴스화 허용
	if (! (this instanceof jQuery.Event)) {
		새 jQuery를 반환합니다. 이벤트 (src, props);
	}

	// 이벤트 객체
	if (src && src.type) {
		this.originalEvent = src;
		this.type = src.type;

		// 문서 위로 부글 거리는 이벤트가 차단 된 것으로 표시되었을 수 있습니다.
		// 처리기가 트리를 아래로 내림; 올바른 값을 반영하십시오.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === 정의되지 않은 &&

				// 지원 : 안드로이드 <= 2.3 만
				src.returnValue === false?
			returnTrue :
			returnFalse;

		// 대상 속성 만들기
		// 지원 : Safari <= 6 - 7 전용
		// 대상은 텍스트 노드가 아니어야합니다 (# 504, # 13143).
		this.target = (src.target && src.target.nodeType === 3)?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// 이벤트 유형
	} else {
		this.type = src;
	}

	// 명시 적으로 제공된 속성을 이벤트 객체에 넣습니다.
	if (props) {
		jQuery.extend (this, props);
	}

	// 들어오는 이벤트에 타임 스탬프가 없으면 타임 스탬프를 만듭니다.
	this.timeStamp = src && src.timeStamp || Date.now ();

	// 고정으로 표시
	this [jQuery.expando] = true;
};

// jQuery.Event는 ECMAScript 언어 바인딩에 지정된 DOM3 이벤트를 기반으로합니다.
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	생성자 : jQuery.Event,
	isDefaultPrevented : returnFalse,
	isPropagationStopped : returnFalse,
	isImmediatePropagationStopped : returnFalse,
	isSimulated : 거짓,

	preventDefault : function () {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if (e &&! this.isSimulated) {
			e.preventDefault ();
		}
	},
	stopPropagation : function () {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if (e &&! this.isSimulated) {
			e.stopPropagation ();
		}
	},
	stopImmediatePropagation : function () {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if (e &&! this.isSimulated) {
			e.stopImmediatePropagation ();
		}

		this.stopPropagation ();
	}
};

// KeyEvent 및 MouseEvent 관련 소품을 포함한 모든 공통 이벤트 소품 포함
jQuery.each ({
	altKey : true,
	거품 : 사실,
	취소 가능 : true,
	changedTouches : true,
	ctrlKey : true,
	세부 정보 : true,
	eventPhase : true,
	metaKey : true,
	pageX : true,
	pageY : 참,
	shiftKey : true,
	뷰 : 참,
	"char": 참,
	charCode : true,
	key : true,
	keyCode : true,
	버튼 : 참,
	버튼 : 참,
	clientX : true,
	clientY : true,
	offsetX : true,
	offsetY : true,
	pointerId : true,
	pointerType : true,
	screenX : 참,
	screenY : 사실,
	targetTouches : true,
	toElement : true,
	접촉 : 사실,

	which : function (event) {
		var button = event.button;

		// 키 이벤트를 추가합니다.
		if (event.which == null && rkeyEvent.test (event.type)) {
			return event.charCode! = null? event.charCode : event.keyCode;
		}

		// 클릭을 위해 어떤 것을 추가 : 1 === 왼쪽; 2 === 중간; 3 === 오른쪽
		if (! event.which && button! == undefined && rmouseEvent.test (event.type)) {
			if (button & 1) {
				1을 반환;
			}

			if (button & 2) {
				return 3;
			}

			if (button & 4) {
				2를 반환;
			}

			0을 반환;
		}

		return event.which;
	}
}, jQuery.event.addProp);

// mouseover / out 및 event-time 검사를 사용하여 mouseenter / leave 이벤트 만들기
// 이벤트 위임이 jQuery에서 작동하도록합니다.
// pointerenter / pointerleave와 pointerover / pointerout에 대해 같은 작업을 수행합니다.
//
// 지원 : Safari 7 만 해당
// Safari가 mouseenter를 너무 자주 보냅니다. 만나다:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// 버그에 대한 설명 (이전 Chrome 버전에도 존재).
jQuery.each ({
	mouseenter : "mouseover",
	mouseleave : "mouseout",
	pointerenter : "포인터 오버",
	pointerleave : "포인터 아웃"
}, function (orig, fix) {
	jQuery.event.special [orig] = {
		delegateType : 수정,
		bindType : 수정,

		핸들 : 함수 (이벤트) {
			var ret,
				target = this,
				관련 = event.relatedTarget,
				handleObj = event.handleObj;

			// mouseenter / leave의 경우 관련이 대상 외부에 있으면 처리기를 호출합니다.
			// NB : 마우스가 왼쪽 / 브라우저 창에 입력되면 관련 타겟 없음
			if (관련! == target &&! jQuery.contains (target, related))) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply (this, arguments);
				event.type = 수정;
			}
			return ret;
		}
	};
});

jQuery.fn.extend ({

	on : 함수 (유형, 선택자, 데이터, fn) {
		반환 (this, types, selector, data, fn);
	},
	하나 : 함수 (유형, 선택자, 데이터, fn) {
		반환 (this, types, selector, data, fn, 1);
	},
	꺼짐 : 기능 (유형, 선택자, fn) {
		var handleObj, type;
		if (types && types.preventDefault && types.handleObj) {

			// (이벤트)가 jQuery.Event를 전달했습니다.
			handleObj = types.handleObj;
			jQuery (types.delegateTarget) .off (
				handleObj.namespace?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			이것을 돌려 보내라.
		}
		if (typeof types === "object") {

			// (types-object [, selector])
			for (유형 입력) {
				this.off (type, selector, types [type]);
			}
			이것을 돌려 보내라.
		}
		if (selector === false || typeof selector === "function") {

			// (유형 [, fn])
			fn = 선택자;
			selector = undefined;
		}
		if (fn === false) {
			fn = returnFalse;
		}
		return this.each (function () {
			jQuery.event.remove (this, types, fn, selector);
		});
	}
});


var

	/ * eslint-disable max-len * /

	// https://github.com/eslint/eslint/issues/3229를 참조하십시오.
	rxhtmlTag = / <(?! area | br | col | embed | hr | img | 입력 | 링크 | 메타 | param) ([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi,

	/ * eslint-enable * /

	// 지원 : IE <= 10 - 11, 가장자리 12 - 13 전용
	// 여기에서 regex 그룹을 사용하는 IE / Edge에서 심각한 감속을 초래합니다.
	// https://connect.microsoft.com/IE/feedback/details/1736512/를 참조하십시오.
	rnoInnerhtml = / <script | <style | <link / i,

	// checked = "checked"또는 checked
	rchecked = /checked\s*(?[^=]|=\s*.checked.)/i,
	rcleanScript = / ^ \ s * <! (? : \ [CDATA \ [| -) | (? : \] \] | -> \ s * $ / g;

// 새 행을 포함하기 위해 부모 테이블보다 tbody를 선호합니다.
function manipulationTarget (elem, content) {
	if (nodeName (elem, "table") &&
		nodeName (content.nodeType! == 11? content : content.firstChild, "tr")) {

		return jQuery (elem) .children ( "tbody") [0] || 엘름;
	}

	return elem;
}

// 안전한 DOM 조작을 위해 스크립트 요소의 type 속성을 바꾸거나 복원하십시오.
함수 disableScript (elem) {
	elem.type = (elem.getAttribute ( "type")! == null) + "/"+ elem.type;
	return elem;
}
function restoreScript (elem) {
	if ((elem.type || "") .slice (0, 5) === "true /") {
		elem.type = elem.type.slice (5);
	} else {
		elem.removeAttribute ( "type");
	}

	return elem;
}

함수 cloneCopyEvent (src, dest) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if (dest.nodeType! == 1) {
		반환;
	}

	// 1. 개인 데이터 복사 : 이벤트, 핸들러 등
	if (dataPriv.hasData (src)) {
		pdataOld = dataPriv.access (src);
		pdataCur = dataPriv.set (dest, pdataOld);
		이벤트 = pdataOld.events;

		if (events) {
			pdataCur.handle을 삭제하십시오;
			pdataCur.events = {};

			for (이벤트 입력) {
				for (i = 0, l = events [type] .length; i <l; i ++) {
					jQuery.event.add (dest, type, events [type] [i]);
				}
			}
		}
	}

	// 2. 사용자 데이터 복사
	if (dataUser.hasData (src)) {
		udataOld = dataUser.access (src);
		udataCur = jQuery.extend ({}, udataOld);

		dataUser.set (dest, udataCur);
	}
}

// IE 버그 수정, 지원 테스트보기
함수 fixInput (src, dest) {
	var nodeName = dest.nodeName.toLowerCase ();

	// 복제 된 확인란이나 라디오 버튼의 선택된 상태를 유지하지 못합니다.
	if (nodeName === "input"&& rcheckableType.test (src.type)) {
		dest.checked = src.checked;

	// 옵션을 복제 할 때 선택한 옵션을 기본 선택 상태로 되돌릴 수 없습니다.
	} else if (nodeName === "input"|| nodeName === "textarea") {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip (콜렉션, args, 콜백, 무시) {

	// 중첩 된 배열을 단순화합니다.
	args = concat.apply ([], args);

	var 프래그먼트, 첫 번째, 스크립트, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = 1 - 1,
		value = args [0],
		valueIsFunction = isFunction (value);

	// 우리는 clone 할 수 없다. checked를 포함하고있는 조각들, WebKit 안에 없다.
	if (valueIsFunction ||
			(1> && 값 유형 === "문자열"&&
				! support.checkClone && rchecked.test (value))) {
		return collection.each (function (index) {
			var self = collection.eq (index);
			if (valueIsFunction) {
				args [0] = value.call (this, index, self.html ());
			}
			domManip (self, args, callback, ignored);
		});
	}

	if (l) {
		fragment = buildFragment (args, collection [0] .ownerDocument, false, collection, ignored);
		first = fragment.firstChild;

		if (fragment.childNodes.length === 1) {
			fragment = first;
		}

		// 무시 된 요소에 새로운 내용이나 관심을 요구하여 콜백을 호출합니다.
		if (처음 || 무시) {
			scripts = jQuery.map (getAll (fragment, "script"), disableScript);
			hasScripts = scripts.length;

			// 마지막 항목에 원래 조각을 사용합니다.
			// 결국 끝날 수 있기 때문에 첫 번째 대신
			// 특정 상황에서 잘못 비워지고 있습니다 (# 8070).
			for (; i <l; i ++) {
				노드 = 프래그먼트;

				if (i! == iNoClone) {
					node = jQuery.clone (node, true, true);

					// 나중에 복원 할 수 있도록 복제 된 스크립트에 대한 참조를 유지합니다.
					if (hasScripts) {

						// 지원 : Android <= 4.0 전용, PhantomJS 1 전용
						// push.apply (_, arraylike) 고대 Webkit을 던졌습니다.
						jQuery.merge (scripts, getAll (node, "script"));
					}
				}

				callback.call (collection [i], node, i);
			}

			if (hasScripts) {
				doc = scripts [scripts.length - 1] .ownerDocument;

				// 스크립트를 다시 활성화하십시오.
				jQuery.map (scripts, restoreScript);

				// 첫 번째 문서 삽입시 실행 스크립트를 평가합니다.
				for (i = 0; i <hasScripts; i ++) {
					node = scripts [i];
					if (rscriptType.test (node.type || "") &&
						! dataPriv.access (node, "globalEval") &&
						jQuery.contains (doc, node)) {

						if (node.src && (node.type || "") .toLowerCase ()! == "module") {

							// AJAX 의존성 옵션 (선택 사항). 존재하지 않으면 스크립트를 실행하지 않습니다.
							if (jQuery._evalUrl) {
								jQuery._evalUrl (node.src);
							}
						} else {
							DOMEval (node.textContent.replace (rcleanScript, ""), doc, node);
						}
					}
				}
			}
		}
	}

	반환 수집;
}

함수 제거 (elem, selector, keepData) {
	var 노드,
		nodes = selector? jQuery.filter (selector, elem) : elem,
		i = 0;

	for (; (node ​​= nodes [i])! = null; i ++) {
		if (! keepData && node.nodeType === 1) {
			jQuery.cleanData (getAll (node));
		}

		if (node.parentNode) {
			if (keepData && jQuery.contains (node.ownerDocument, node)) {
				setGlobalEval (getAll (node, "script"));
			}
			node.parentNode.removeChild (node);
		}
	}

	return elem;
}

jQuery.extend ({
	htmlPrefilter : function (html) {
		return html.replace (rxhtmlTag, "<$ 1> </ $ 2>");
	},

	clone : function (elem, dataAndEvents, deepDataAndEvents) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode (true),
			inPage = jQuery.contains (elem.ownerDocument, elem);

		// IE 복제 문제 수정
		if (! support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
				! jQuery.isXMLDoc (elem)) {

			// 성능상의 이유로 Sizzle을 피했습니다 : https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll (복제);
			srcElements = getAll (elem);

			for (i = 0, l = srcElements.length; i <l; i ++) {
				fixInput (srcElements [i], destElements [i]);
			}
		}

		// 이벤트를 원본에서 복제본으로 복사합니다.
		if (dataAndEvents) {
			if (deepDataAndEvents) {
				srcElements = srcElements || getAll (elem);
				destElements = destElements || getAll (복제);

				for (i = 0, l = srcElements.length; i <l; i ++) {
					cloneCopyEvent (srcElements [i], destElements [i]);
				}
			} else {
				cloneCopyEvent (elem, clone);
			}
		}

		// 스크립트 평가 기록 보존
		destElements = getAll (복제, "스크립트");
		if (destElements.length> 0) {
			setGlobalEval (destElements,! inPage && getAll (elem, "script")));
		}

		// 복제 된 집합을 반환합니다.
		반환 복제품;
	},

	cleanData : function (elems) {
		var 데이터, elem, type,
			특별 = jQuery.event.special,
			i = 0;

		for (; (elem = elems [i])! == undefined; i ++) {
			if (acceptData (elem)) {
				if ((data = elem [dataPriv.expando])) {
					if (data.events) {
						for (data.events에 입력) {
							if (특수 [유형]) {
								jQuery.event.remove (elem, type);

							// 이것은 jQuery.event.remove의 오버 헤드를 피하기위한 지름길이다.
							} else {
								jQuery.removeEvent (elem, type, data.handle);
							}
						}
					}

					// 지원 : Chrome <= 35 - 45+
					// delete를 사용하는 대신에 undefined를 지정한다. See data # remove
					elem [dataPriv.expando] = 정의되지 않음;
				}
				if (elem [dataUser.expando]) {

					// 지원 : Chrome <= 35 - 45+
					// delete를 사용하는 대신에 undefined를 지정한다. See data # remove
					elem [dataUser.expando] = 정의되지 않음;
				}
			}
		}
	}
});

jQuery.fn.extend ({
	detach : function (선택자) {
		반환 제거 (this, selector, true);
	},

	제거 : function (selector) {
		return remove (this, selector);
	},

	텍스트 : 함수 (값) {
		반환 액세스 (this, function (value) {
			반환 값 === undefined?
				jQuery.text (this) :
				this.empty (). 각 (function () {
					if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length);
	},

	append : function () {
		return domManip (this, arguments, function (elem) {
			if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
				var target = manipulationTarget (this, elem);
				target.appendChild (elem);
			}
		});
	},

	앞에 추가 : function () {
		return domManip (this, arguments, function (elem) {
			if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
				var target = manipulationTarget (this, elem);
				target.insertBefore (elem, target.firstChild);
			}
		});
	},

	before : function () {
		return domManip (this, arguments, function (elem) {
			if (this.parentNode) {
				this.parentNode.insertBefore (elem, this);
			}
		});
	},

	이후 : function () {
		return domManip (this, arguments, function (elem) {
			if (this.parentNode) {
				this.parentNode.insertBefore (elem, this.nextSibling);
			}
		});
	},

	empty : function () {
		var elem,
			i = 0;

		for (; (elem = this [i])! = null; i ++) {
			if (elem.nodeType === 1) {

				// 메모리 누수 방지
				jQuery.cleanData (getAll (elem, false));

				// 나머지 노드를 제거합니다.
				elem.textContent = "";
			}
		}

		이것을 돌려 보내라.
	},

	복제 : 함수 (dataAndEvents, deepDataAndEvents) {
		dataAndEvents = dataAndEvents == null? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null? dataAndEvents : deepDataAndEvents;

		반환 this.map (function () {
			return jQuery.clone (this, dataAndEvents, deepDataAndEvents);
		});
	},

	html : function (value) {
		반환 액세스 (this, function (value) {
			var elem = this [0] || {},
				i = 0,
				l = this.length;

			if (value === undefined && elem.nodeType === 1) {
				return elem.innerHTML;
			}

			// 바로 가기를 사용하고 innerHTML을 사용할 수 있는지 확인하십시오.
			if (typeof value === "string"&&! rnoInnerhtml.test (value) &&
				! wrapMap [(rtagName.exec (value) || [ "", ""]) [1] .toLowerCase ()]) {

				value = jQuery.htmlPrefilter (value);

				시도 {
					for (; i <l; i ++) {
						elem = this [i] || {};

						// 요소 노드를 제거하고 메모리 누수를 방지합니다.
						if (elem.nodeType === 1) {
							jQuery.cleanData (getAll (elem, false));
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// innerHTML을 사용하여 예외를 throw하는 경우 fallback 메서드를 사용합니다.
				} catch (e) {}
			}

			if (elem) {
				this.empty (). append (value);
			}
		}, null, value, arguments.length);
	},

	replaceWith : function () {
		var ignored = [];

		// 변경 사항을 적용하여 무시되지 않은 각 컨텍스트 요소를 새 내용으로 대체합니다.
		return domManip (this, arguments, function (elem) {
			var parent = this.parentNode;

			if (jQuery.inArray (this, ignored) <0) {
				jQuery.cleanData (getAll (this));
				if (parent) {
					parent.replaceChild (elem, this);
				}
			}

		// 강제 콜백 호출
		}, 무시);
	}
});

jQuery.each ({
	appendTo : "append",
	prependTo : "prepend",
	insertBefore : "전에",
	insertAfter : "이후",
	replaceAll : "replaceWith"
}, 함수 (이름, 원본) {
	jQuery.fn [name] = 함수 (selector) {
		var elems,
			ret = [],
			insert = jQuery (selector),
			last = insert.length - 1,
			i = 0;

		for (; i <= last; i ++) {
			elems = i === 마지막으로? this : this.clone (true);
			jQuery ([i] 삽입) [원본] (elems);

			// 지원 : Android <= 4.0 전용, PhantomJS 1 전용
			//.get () 왜냐하면 push.apply (_, arraylike)가 고대 WebKit을 던지기 때문입니다.
			push.apply (ret, elems.get ());
		}

		return this.pushStack (ret);
	};
});
var rnumnonpx = new RegExp ( "^ ("+ pnum + ") (?! px) [az %] + $", "i");

var getStyles = function (elem) {

		// 지원 : IE <= 11 전용, Firefox <= 30 (# 15098, # 14150)
		// IE에서 팝업으로 생성 된 요소를 던집니다.
		// FF는 "defaultView.getComputedStyle"을 통해 프레임 요소를 던집니다.
		var view = elem.ownerDocument.defaultView;

		if (! view ||! view.opener) {
			보기 = 창;
		}

		return view.getComputedStyle (elem);
	};

var rboxStyle = 새 RegExp (cssExpand.join ( "|"), "i");



(function () {

	// pixelPosition과 boxSizingReliable 테스트를 모두 실행하려면 레이아웃이 하나만 필요합니다.
	// 두 번째 계산을 저장하기 위해 동시에 실행됩니다.
	함수 computeStyleTests () {

		// 이것은 싱글 톤이므로 한 번만 실행해야합니다.
		if (! div) {
			반환;
		}

		container.style.cssText = "위치 : 절대, 왼쪽 : -11111px, 너비 : 60px;" +
			"margin-top : 1px, padding : 0, border : 0";
		div.style.cssText =
			"위치 : 상대적, 디스플레이 : 블록, 상자 크기 : 테두리 상자, 오버플로 : 스크롤," +
			"margin : 자동, border : 1px, padding : 1px" +
			"너비 : 60 %, 상단 : 1 %";
		documentElement.appendChild (container) .appendChild (div);

		var divStyle = window.getComputedStyle (div);
		pixelPositionVal = divStyle.top! == "1 %";

		// 지원 : Android 4.0 - 4.3 전용, Firefox <= 3 - 44
		reliableMarginLeftVal = roundPixelMeasures (divStyle.marginLeft) === 12;

		// 지원 : Android 4.0 - 4.3 전용, Safari <= 9.1 - 10.1, iOS <= 7.0 - 9.3
		// 일부 스타일은 백분율 값을 반환합니다.
		div.style.right = "60 %";
		pixelBoxStylesVal = roundPixelMeasures (divStyle.right) === 36;

		// 지원 : IE 9 - 11 전용
		// 상자 크기에 대한 내용 크기의 잘못보고 감지 : 테두리 상자 요소
		boxSizingReliableVal = roundPixelMeasures (divStyle.width) === 36;

		// 지원 : IE 9 만
		// 오버플로 감지 : 스크롤 성 비틀림 (gh-3699)
		div.style.position = "절대";
		scrollboxSizeVal = div.offsetWidth === 36 || "순수한";

		documentElement.removeChild (container);

		// div가 메모리에 저장되지 않도록 무효화합니다.
		// 이미 수행 된 검사도 표시됩니다.
		div = null;
	}

	function roundPixelMeasures (measure) {
		return Math.round (parseFloat (measure));
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement ( "div"),
		div = document.createElement ( "div");

	// 제한된 (브라우저가 아닌) 환경에서 일찍 끝내라.
	if (! div.style) {
		반환;
	}

	// 지원 : IE <= 9 - 11 전용
	// 복제 된 요소의 스타일이 복제 된 소스 요소에 영향을 미침 (# 8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode (true) .style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend (지원, {
		boxSizingReliable : function () {
			computeStyleTests ();
			return boxSizingReliableVal;
		},
		pixelBoxStyles : function () {
			computeStyleTests ();
			return pixelBoxStylesVal;
		},
		pixelPosition : function () {
			computeStyleTests ();
			return pixelPositionVal;
		},
		reliableMarginLeft : function () {
			computeStyleTests ();
			return reliableMarginLeftVal;
		},
		scrollboxSize : function () {
			computeStyleTests ();
			scrollboxSizeVal를 반환합니다.
		}
	});
}) ();


함수 curCSS (elem, 이름, 계산) {
	var width, minWidth, maxWidth, ret,

		// 지원 : Firefox 51 이상
		// 어떻게 든 계산되기 전에 스타일 가져 오기
		// 잘못된 값을 가져 오는 문제를 해결합니다.
		// 분리 된 요소에
		스타일 = elem.style;

	calculated = 계산 된 || getStyles (elem);

	// getPropertyValue는 다음에 필요합니다.
	// .css ( 'filter') (IE 9 전용, # 12537)
	// .css ( '- customProperty) (# 3144)
	if (calculated) {
		ret = computed.getPropertyValue (name) || 계산 된 [이름];

		if (ret === ""&&! jQuery.contains (elem.ownerDocument, elem)) {
			ret = jQuery.style (elem, name);
		}

		// 딘 에드워즈 (Dean Edwards)의 "굉장한 해킹"에 대한 찬사
		// Android Browser는 일부 값의 백분율을 반환하지만,
		// 너비는 확실히 픽셀 인 것처럼 보입니다.
		// CSSOM 초안에 위배됩니다.
		// https://drafts.csswg.org/cssom/#resolved-values
		if (! support.pixelBoxStyles () && rnumnonpx.test (ret) && rboxStyle.test (name)) {

			// 원래 값을 기억하십시오.
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// 새로운 값을 입력하여 계산 된 값을 출력합니다.
			style.minWidth = style.maxWidth = style.width = ret;
			ret = calculated.width;

			// 변경된 값 되돌리기
			style.width = 너비;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret! == undefined?

		// 지원 : IE <= 9 - 11 전용
		// IE는 zIndex 값을 정수로 반환합니다.
		ret + "":
		ret;
}


function addGetHookIf (conditionFn, hookFn) {

	// 후크를 정의하면 처음 실행이 실제로 필요한지 확인합니다.
	반환 {
		get : function () {
			if (conditionFn ()) {

				// 필요하지 않은 훅 (또는 그것을 사용할 수 없습니다.
				// 종속성이 누락 된 경우) 제거하십시오.
				삭제 this.get;
				반환;
			}

			// 필요한 후크; 지원 테스트가 다시 실행되지 않도록 다시 정의하십시오.
			return (this.get = hookFn) .apply (this, arguments);
		}
	};
}


var

	// display가 none이거나 table로 시작하면 교체 가능
	// "table", "table-cell"또는 "table-caption"을 제외하고
	// 표시 값은 https://developer.mozilla.org/en-US/docs/CSS/display에서 확인하십시오.
	rdisplayswap = / ^ (none | table (?! - c [ea]). +) /,
	rcustomProp = / ^ - /,
	cssShow = {위치 : "절대", 가시성 : "숨김", 디스플레이 : "블록"},
	cssNormalTransform = {
		letterSpacing : "0",
		fontWeight : "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms"],
	emptyStyle = document.createElement ( "div") .style;

// 잠재적으로 접두사가 붙은 속성에 매핑 된 css 속성을 반환합니다.
function vendorPropName (name) {

	// 공급 업체 접두사가 아닌 이름의 바로 가기
	if (name in emptyStyle) {
		반환 이름;
	}

	// 접두어 접두사 이름 확인
	var capName = name [0] .toUpperCase () + name.slice (1),
		i = cssPrefixes.length;

	while (i--) {
		name = cssPrefixes [i] + capName;
		if (name in emptyStyle) {
			반환 이름;
		}
	}
}

// jQuery.cssProps가 제안하거나 따라 매핑 된 속성을 반환합니다.
// 접두어 붙은 속성.
function finalPropName (name) {
	var ret = jQuery.cssProps [name];
	if (! ret) {
		ret = jQuery.cssProps [name] = vendorPropName (name) || 이름;
	}
	return ret;
}

함수 setPositiveNumber (elem, value, 빼기) {

	// 상대적인 (+/-) 값은 이미
	//이 시점에서 정규화 됨
	var matches = rcssNum.exec (value);
	반환 일치?

		// cssHooks와 같이 사용될 때, undefined "subtract"에 대한 감시.
		Math.max (0, matches [2] - (빼기 || 0)) + ([3] || "px"와 일치) :
		값;
}

function boxModelAdjustment (elem, dimension, box, isBorderBox, styles, computedVal) {
	var i = dimension === "width"? 1 : 0,
		추가 = 0,
		델타 = 0;

	// 조정이 필요하지 않을 수도 있습니다.
	if (box === (isBorderBox? "border": "content")) {
		0을 반환;
	}

	for (; i <4; i + = 2) {

		// 양쪽 상자 모델은 여백을 제외합니다.
		if (box === "margin") {
			delta + = jQuery.css (elem, box + cssExpand [i], true, styles);
		}

		// content-box를 가지고 여기에 "padding"또는 "border"또는 "margin"을 찾으면
		if (! isBorderBox) {

			// 패딩 추가
			delta + = jQuery.css (elem, "패딩"+ cssExpand [i], true, styles);

			// "border"또는 "margin"의 경우 테두리 추가
			if (box! == "패딩") {
				delta + = jQuery.css (elem, "border"+ cssExpand [i] + "Width", true, styles);

			// 그래도 계속 추적합니다.
			} else {
				extra + = jQuery.css (elem, "border"+ cssExpand [i] + "Width", true, styles);
			}

		// border-box (content + padding + border)를 사용하면 여기에 "content"또는
		// "패딩"또는 "여백"
		} else {

			// "content"의 경우, 뺄셈 패딩
			if (box === "content") {
				delta - = jQuery.css (elem, "패딩"+ cssExpand [i], true, styles);
			}

			// "content"또는 "padding"의 경우 테두리를 뺍니다.
			if (box! == "margin") {
				delta - = jQuery.css (elem, "border"+ cssExpand [i] + "Width", true, styles);
			}
		}
	}

	// calculateVal을 제공하여 요청시 양수 컨텐트 상자 스크롤 제본 용 어카운트를 설명합니다.
	if (! isBorderBox && computedVal> = 0) {

		// offsetWidth / offsetHeight는 내용, 채우기, 스크롤 거터 및 테두리의 반올림 합계입니다.
		// 정수 스크롤 거터를 가정하고, 나머지를 뺀 다음 반올림합니다.
		delta + = Math.max (0, Math.ceil (
			elem [ "offset"+ dimension [0] .toUpperCase () + dimension.slice (1)] -
			computedVal -
			델타 -
			여분 -
			0.5
		));
	}

	델타를 반환합니다.
}

함수 getWidthOrHeight (elem, dimension, extra) {

	// 계산 된 스타일로 시작
	var styles = getStyles (elem),
		val = curCSS (엘름, 치수, 스타일),
		isBorderBox = jQuery.css (elem, "boxSizing", false, styles) === "border-box",
		valueIsBorderBox = isBorderBox;

	// 지원 : Firefox <= 54
	// 혼란스럽지 않은 비 - 픽셀 값을 반환하거나, 무지를 가두십시오.
	if (rnumnonpx.test (val)) {
		if (! extra) {
			반환 가치;
		}
		val = "auto";
	}

	// 신뢰할 수없는 값을 반환하는 브라우저의 경우 스타일을 확인합니다.
	// getComputedStyle에 대해 자동으로 신뢰할 수있는 elem.style로 떨어집니다.
	valueIsBorderBox = valueIsBorderBox &&
		(support.boxSizingReliable () || val === elem.style [dimension]);

	// 값이 "auto"이면 offsetWidth / offsetHeight로 다시 떨어집니다.
	// 명시 적 설정이없는 인라인 요소에서 발생합니다 (gh-3571).
	// 지원 : 안드로이드 <= 4.1 - 4.3 전용
	// 잘못보고 된 인라인 크기 (gh-3602)에도 offsetWidth / offsetHeight를 사용합니다.
	if (val === "auto"||
		! parseFloat (val) && jQuery.css (elem, "display", false, styles) === "인라인") {

		val = elem [ "offset"+ dimension [0] .toUpperCase () + dimension.slice (1)];

		// offsetWidth / offsetHeight는 테두리 상자 값을 제공합니다.
		valueIsBorderBox = true;
	}

	// ""표준화하고 auto
	val = parseFloat (val) || 0;

	// 요소의 상자 모델에 맞게 조정합니다.
	반환 (val +
		boxModelAdjustment (
			elem,
			치수,
			여분의 || (isBorderBox? "border": "content"),
			valueIsBorderBox,
			스타일,

			// 현재 계산 된 크기를 제공하여 스크롤 거터 계산을 요청합니다 (gh-3589).
			발
		)
	) + "px";
}

jQuery.extend ({

	// 기본값을 재정의하기 위해 스타일 속성 훅을 추가합니다.
	// 스타일 속성 가져 오기 및 설정 동작
	css 후크 : {
		불투명 : {
			get : function (elem, calculated) {
				if (calculated) {

					// 항상 불투명 한 숫자를 반환해야합니다.
					var ret = curCSS (elem, "opacity");
					return ret === ""? "1": ret;
				}
			}
		}
	},

	// 이러한 단위가없는 속성에 "px"를 자동으로 추가하지 않습니다.
	cssNumber : {
		"animationIterationCount": 참,
		"columnCount": 참,
		"fillOpacity": 참,
		"flexGrow": true,
		"flexShrink": 참,
		"fontWeight": true,
		"lineHeight": 참,
		"opacity": true,
		"주문": 사실,
		"고아": 사실,
		"미망인": 사실,
		"zIndex": 참,
		"확대 / 축소": 참
	},

	// 이전에 수정하고자하는 이름의 속성을 추가합니다.
	// 값 설정 또는 가져 오기
	cssProps : {},

	// DOM 노드에서 스타일 속성 가져 오기 및 설정
	스타일 : 함수 (elem, name, value, extra) {

		// 텍스트 및 주석 노드에 스타일을 설정하지 않습니다.
		만약 (! ELEM || elem.nodeType의 === 3 || elem.nodeType의 === 8 ||! elem.style) {
			반환;
		}

		// 우리가 올바른 이름으로 작업하고 있는지 확인하십시오.
		var ret, type, hooks,
			origName = camelCase (name),
			isCustomProp = rcustomProp.test (name),
			스타일 = elem.style;

		// 우리가 올바른 이름으로 작업하고 있는지 확인하십시오. 우리는하지 않는다.
		// CSS 사용자 정의 속성 인 경우 값을 쿼리하려고합니다.
		// 그들은 사용자 정의이기 때문에.
		if (! isCustomProp) {
			name = finalPropName (origName);
		}

		// 접두어가 붙은 버전에 대한 후크를 가져온 다음 접미어가없는 버전
		hooks = jQuery.cssHooks [name] || jQuery.cssHooks [origName];

		// 값을 설정하는지 확인
		if (value! == undefined) {
			type = typeof value;

			// "+ ="또는 "- ="을 상대 번호로 변환합니다 (# 7345)
			if (type === "string"&& (ret = rcssNum.exec (value)) && ret [1]) {
				value = adjustCSS (elem, name, ret);

				// 버그 # 9237 수정
				type = "number";
			}

			// null 및 NaN 값이 설정되지 않았는지 확인합니다 (# 7116).
			if (value == null || value! == value) {
				반환;
			}

			// 숫자가 전달 된 경우 유닛을 추가합니다 (특정 CSS 속성 제외).
			if (type === "number") {
				value + = ret && ret [3] || (jQuery.cssNumber [origName]? "": "px");
			}

			// background- * props는 원래 복제본의 값에 영향을줍니다.
			if (! support.clearCloneStyle && value === ""&& name.indexOf ( "background") === 0) {
				스타일 [이름] = "상속";
			}

			// hook이 제공되면, 그 값을 사용하고, 그렇지 않으면, 지정된 값을 설정한다.
			if (! hooks ||! (후크에 "set") ||
				(value = hooks.set (elem, value, extra))! == undefined) {

				if (isCustomProp) {
					style.setProperty (name, value);
				} else {
					스타일 [이름] = 값;
				}
			}

		} else {

			// hook이 제공되면 거기에서 계산되지 않은 값을 얻는다.
			if (hooks && "get"in hooks &&
				(ret = hooks.get (elem, false, extra))! == undefined) {

				return ret;
			}

			// 그렇지 않으면 스타일 객체에서 값을 가져옵니다.
			반환 스타일 [이름];
		}
	},

	CSS : function (elem, name, extra, styles) {
		var val, num, hooks,
			origName = camelCase (name),
			isCustomProp = rcustomProp.test (name);

		// 우리가 올바른 이름으로 작업하고 있는지 확인하십시오. 우리는하지 않는다.
		// CSS 사용자 정의 속성 인 경우 값을 수정하려고합니다.
		// 그들은 사용자 정의이기 때문에.
		if (! isCustomProp) {
			name = finalPropName (origName);
		}

		// 접두사가 붙은 이름 다음에 접두어가없는 이름이 오는 지 시도하십시오.
		hooks = jQuery.cssHooks [name] || jQuery.cssHooks [origName];

		// hook이 제공되면 거기에서 계산 된 값을 얻는다.
		if (hooks && "hook in") {
			val = hooks.get (elem, true, extra);
		}

		// 그렇지 않으면 계산 된 값을 가져 오는 방법이 있으면
		if (val === undefined) {
			val = curCSS (elem, name, styles);
		}

		// "normal"을 계산 된 값으로 변환합니다.
		if (val === "normal"&& cssNormalTransform의 이름) {
			val = cssNormalTransform [name];
		}

		// 강제 실행되거나 한정자가 제공되고 val이 숫자로 보이면 숫자로 만듭니다.
		if (extra === ""| extra) {
			num = parseFloat (val);
			여분의 것을 돌려라 === true || isFinite (num)? num || 0 : val;
		}

		반환 가치;
	}
});

jQuery.each ([ "height", "width"], function (i, dimension) {
	jQuery.cssHooks [dimension] = {
		get : function (elem, calculated, extra) {
			if (calculated) {

				// 보이지 않게 표시하는 경우 특정 요소에 치수 정보가 포함될 수 있습니다.
				// 이점을 얻을 수있는 현재 표시 스타일을 가져야합니다.
				return rdisplayswap.test (jQuery.css (elem, "display")) &&

					// 지원 : Safari 8 이상
					// Safari의 표 열에 offsetWidth가 0이 아닌 값이 0이됩니다.
					// getBoundingClientRect (). 디스플레이가 변경되지 않는 한 너비.
					// 지원 : IE <= 11 만
					// 연결 해제 된 노드에서 getBoundingClientRect 실행하기
					// IE에서 오류가 발생합니다.
					(! elem.getClientRects (). length ||! elem.getBoundingClientRect (). width)?
						스왑 (elem, cssShow, function () {
							반환 getWidthOrHeight (elem, dimension, extra);
						}) :
						getWidthOrHeight (elem, dimension, extra);
			}
		},

		세트 : function (elem, value, extra) {
			var 일치,
				스타일 = getStyles (elem),
				isBorderBox = jQuery.css (elem, "boxSizing", false, styles) === "border-box",
				빼기 = 추가 && boxModelAdjustment (
					elem,
					치수,
					특별한,
					isBorderBox,
					스타일
				);

			// 옵셋을 계산 된 값과 비교하여 신뢰할 수없는 경계 상자 차원을 계산합니다.
			// 경계 상자와 패딩을 가져 오기 위해 컨텐트 상자 위조 (gh-3699)
			if (isBorderBox && support.scrollboxSize () === styles.position) {
				빼기 - = Math.ceil (
					elem [ "offset"+ dimension [0] .toUpperCase () + dimension.slice (1)] -
					parseFloat (styles [dimension]) -
					boxModelAdjustment (elem, dimension, "border", false, styles) -
					0.5
				);
			}

			// 값 조정이 필요한 경우 픽셀로 변환
			if (&& (matches = rcssNum.exec (value)) &&
				([3] || "px"와 일치합니다!) == "px") {

				elem.style [dimension] = 값;
				값 = jQuery.css (elem, dimension);
			}

			반환 값 setPositiveNumber (elem, value, subtract);
		}
	};
});

jQuery.cssHooks.marginLeft = addGetHookIf (support.reliableMarginLeft,
	함수 (elem, calculated) {
		if (calculated) {
			return (parseFloat (curCSS (elem, "marginLeft")) ||
				elem.getBoundingClientRect (). left -
					스왑 (elem, {marginLeft : 0}, function () {
						return elem.getBoundingClientRect (). left;
					})
				) + "px";
		}
	}
);

// 이러한 후크는 animate에서 속성을 확장하는 데 사용됩니다.
jQuery.each ({
	여백 : "",
	패딩 : "",
	테두리 : "너비"
}, function (접두사, 접미사) {
	jQuery.cssHooks [접두사 + 접미사] = {
		확장 : function (value) {
			var i = 0,
				확장 = {},

				// 문자열이 아닌 경우 하나의 숫자를 가정합니다.
				부품 = 값 유형 === "문자열"? value.split ( "") : [값];

			for (; i <4; i ++) {
				expanded [prefix + cssExpand [i] + suffix] =
					부품 [i] || 부품 [i - 2] || 부품 [0];
			}

			반환 확장;
		}
	};

	if (prefix! = "margin") {
		jQuery.cssHooks [접두사 + 접미사] .set = setPositiveNumber;
	}
});

jQuery.fn.extend ({
	CSS : 함수 (이름, 값) {
		반환 액세스 (this, function (elem, name, value) {
			var 스타일, len,
				map = {},
				i = 0;

			if (Array.isArray (name)) {
				스타일 = getStyles (elem);
				len = name.length;

				for (; i <len; i ++) {
					map [name [i]] = jQuery.css (elem, name [i], false, styles);
				}

				반환지도;
			}

			반환 값! == undefined?
				jQuery.style (elem, name, value) :
				jQuery.css (elem, name);
		}, name, value, arguments.length> 1);
	}
});


함수 Tween (elem, 옵션, 소품, 종료, 여유) {
	새로운 Tween.prototype.init (elem, options, prop, end, easing)를 반환합니다.
}
jQuery.Tween = Tween;

Tween.prototype = {
	생성자 : Tween,
	init : 함수 (elem, options, prop, end, easing, unit) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur ();
		this.end = end;
		this.unit = unit || (jQuery.cssNumber [prop]? "": "px");
	},
	cur : function () {
		var hooks = Tween.propHooks [this.prop];

		return hooks && hooks.get?
			hooks.get (this) :
			Tween.propHooks._default.get (this);
	},
	실행 : function (percent) {
		var 쉽게,
			후크 = Tween.propHooks [this.prop];

		if (this.options.duration) {
			this.pos = eased = jQuery.easing [this.easing] (
				퍼센트, this.options.duration * 퍼센트, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = (this.end - this.start) * 쉬워 진 this.start;

		if (this.options.step) {
			this.options.step.call (this.elem, this.now, this);
		}

		if (hooks && hooks.set) {
			hooks.set (this);
		} else {
			Tween.propHooks._default.set (this);
		}
		이것을 돌려 보내라.
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default : {
		get : function (tween) {
			var result;

			// DOM 요소가 아닌 경우 요소의 속성을 직접 사용하고,
			// 또는 존재하는 스타일 속성이 없을 때.
			if (tween.elem.nodeType! == 1 ||
				tween.elem [tween.prop]! = null && tween.elem.style [tween.prop] == null) {
				return tween.elem [tween.prop];
			}

			// 빈 문자열을 .css의 세 번째 매개 변수로 전달하면 자동으로
			// 구문 분석에 실패하면 parseFloat를 시도하고 문자열로 대체합니다.
			// "10px"와 같은 간단한 값은 Float로 파싱됩니다.
			// "rotate (1rad)"와 같은 복합 값은있는 그대로 반환됩니다.
			결과 = jQuery.css (tween.elem, tween.prop, "");

			// 빈 문자열, null, undefined 및 "auto"는 0으로 변환됩니다.
			돌아오다! 결과 || 결과 === "자동"? 0 : 결과;
		},
		설정 : 함수 (트윈) {

			// 이전 버전과의 호환을 위해 스텝 후크를 사용합니다.
			// cssHook이 있으면 사용하십시오.
			// 가능한 경우 .style을 사용하고 가능한 경우 일반 속성을 사용하십시오.
			if (jQuery.fx.step [tween.prop]) {
				jQuery.fx.step [tween.prop] (트윈);
			} else if (tween.elem.nodeType === 1 &&
				(tween.elem.style [jQuery.cssProps [tween.prop]]! = null ||
					jQuery.cssHooks [tween.prop])) {
				jQuery.style (tween.elem, tween.prop, tween.now + tween.unit);
			} else {
				tween.elem [tween.prop] = tween.now;
			}
		}
	}
};

// 지원 : IE <= 9 만
// 연결이 끊어진 노드의 설정에 대한 패닉 기반 접근 방식
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	설정 : 함수 (트윈) {
		if (tween.elem.nodeType && tween.elem.parentNode) {
			tween.elem [tween.prop] = tween.now;
		}
	}
};

jQuery.easing = {
	선형 함수 (p) {
		p를 반환;
	},
	스윙 : function (p) {
		return 0.5 - Math.cos (p * Math.PI) / 2;
	},
	_default : "스윙"
};

jQuery.fx = Tween.prototype.init;

// 뒷면 호환성 <1.8 확장 점
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = / ^ (?: toggle | show | hide) $ /,
	rrun = / queueHooks $ /;

함수 일정 () {
	if (inProgress) {
		if (document.hidden === false && window.requestAnimationFrame) {
			window.requestAnimationFrame (schedule);
		} else {
			window.setTimeout (schedule, jQuery.fx.interval);
		}

		jQuery.fx.tick ();
	}
}

// 동 기적으로 생성 된 애니메이션은 동 기적으로 실행됩니다.
함수 createFxNow () {
	window.setTimeout (function () {
		fxNow = 정의되지 않음;
	});
	return (fxNow = Date.now ());
}

// 매개 변수를 생성하여 표준 애니메이션을 만듭니다.
함수 genFx (type, includeWidth) {
	var,
		i = 0,
		attrs = {높이 : 유형};

	// 너비를 포함하면 모든 cssExpand 값을 수행하기위한 단계 값은 1이고,
	// 그렇지 않으면 스텝 값은 2이고 왼쪽과 오른쪽으로 건너 뜁니다.
	includeWidth = includeWidth? 1 : 0;
	for (; i <4; i + = 2 - includeWidth) {
		which = cssExpand [i];
		attrs [ "margin"+ which] = attrs [ "padding"+ which] = type;
	}

	if (includeWidth) {
		attrs.opacity = attrs.width = type;
	}

	attrs를 반환;
}

function createTween (value, prop, animation) {
	var tween,
		collection = (Animation.tweeners [prop] || []) .concat (Animation.tweeners [ "*"]),
		인덱스 = 0,
		length = collection.length;
	for (; index <length; index ++) {
		if ((tween = collection [index] .call (animation, prop, value))) {

			//이 속성으로 끝났습니다.
			리턴 트윈;
		}
	}
}

function defaultPrefilter (elem, props, opts) {
	var prop, value, 토글, 후크, oldfire, propTween, restoreDisplay, display,
		isBox = "소도구의 너비"|| 소품의 "높이"
		anim = this,
		orig = {},
		스타일 = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree (elem),
		dataShow = dataPriv.get (elem, "fxshow");

	// 대기열 건너 뛰기 애니메이션이 fx 후크를 납치합니다.
	if (! opts.queue) {
		후크 = jQuery._queueHooks (elem, "fx");
		if (hooks.unqueued == null) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function () {
				if (! hooks.unqueued) {
					oldfire ();
				}
			};
		}
		hooks.unqueued ++;

		anim.always (function () {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );